<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üåå Orbital Navigation - Training Ground</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='75' font-size='80'>üõ∏</text></svg>">
  
  <!-- PARASITIC DEPENDENCIES -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  
  <!-- PSYCHOGRAPH INTEGRATION - Updates radar based on avatar movement -->
  <script src="integrate-psychograph-updates.js"></script>
  
  <!-- NODE VIEWER INTEGRATION - Makes grid cells clickable, shows node data in chat -->
  <script src="node-viewer-integration.js"></script>
  
  <style>
    /* ========================================
       ORBITAL NAVIGATION TRAINING GROUND
       Inspired by: t-01.html minimal space aesthetic
       ======================================== */
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    :root {
      --transition: cubic-bezier(0.4, 0, 0.2, 1);
      --column-width: min(100vw, 420px);
    }

    body {
      --bg: #0b0d10;
      --panel: #11151aee;
      --panel-dark: #0e1116aa;
      --border: #2a323a;
      --border-light: #3a4249;
      --text: #e9e9e9;
      --text-muted: #9aa3ad;
      --accent: #ff4d2e;
      --accent-soft: rgba(255, 77, 46, 0.12);
      --accent-glow: rgba(255, 77, 46, 0.32);
      --danger: #ff5c7c;
      --success: #56ff9f;
      --grid-highlight: rgba(255, 77, 46, 0.08);
      --shadow: rgba(0, 0, 0, 0.45);
      --overlay-backdrop: rgba(11, 13, 16, 0.88);
      font-family: 'Courier New', monospace;
      font-size: clamp(11px, 2.4vw, 13px);
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
      min-height: 100vh;
    }

    /* APP SHELL */
    .app-shell {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    /* CHANNEL SCROLLER */
    .scroll-container {
      flex: 1;
      display: flex;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-snap-type: x mandatory;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      background: var(--bg);
      gap: 1px;
      border-top: 1px solid var(--border);
    }

    .channel-scroller {
      display: flex;
      overflow-x: auto;
      overflow-y: hidden;
      gap: 0;
      scroll-snap-type: x mandatory;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      position: relative;
    }

    /* CHANNEL COLUMN */
    .channel-column {
      position: relative;
      flex: 0 0 var(--column-width);
      max-width: var(--column-width);
      height: calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      background: var(--panel-dark);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      scroll-snap-align: start;
      overflow: hidden;
      padding-bottom: 60px; /* Space for floating global footer */
      box-sizing: border-box;
      transition: flex 0.4s var(--transition), max-width 0.4s var(--transition);
    }
    
    .channel-column.collapsed {
      flex: 0 0 52px;
      max-width: 52px;
      min-width: 52px;
    }
    
    .channel-column.collapsed .train-viewport,
    .channel-column.collapsed .chat-section,
    .channel-column.collapsed .channel-footer {
      opacity: 0;
      pointer-events: none;
    }
    
    /* EXPAND TAB for collapsed channels */
    .channel-expand-tab {
      position: absolute;
      left: 52px;
      top: 50%;
      transform: translateY(-50%);
      width: 32px;
      height: 100px;
      background: var(--panel);
      border: 2px solid var(--border);
      border-left: none;
      border-radius: 0 8px 8px 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      cursor: pointer;
      z-index: 50;
      box-shadow: 2px 0 8px var(--shadow);
      transition: all 0.2s var(--transition);
    }
    
    .channel-column.collapsed .channel-expand-tab {
      display: flex;
    }
    
    .channel-expand-tab:hover {
      background: var(--accent);
    }
    
    .channel-expand-tab:hover > div {
      color: var(--bg);
    }

    /* CHANNEL HEADER */
    .channel-head {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: stretch;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      flex-shrink: 0;
    }
    
    .channel-column.collapsed .channel-head {
      opacity: 0;
      pointer-events: none;
    }
    
    .channel-actions {
      display: flex;
      gap: 6px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .channel-btn {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.25s var(--transition);
    }
    
    .channel-btn.fullscreen-mode {
      background: var(--accent);
      color: var(--bg);
    }
    
    .channel-btn:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }
    
    .channel-btn:active {
      transform: scale(0.9);
    }
    
    /* CAMERA COMMAND STYLING IN CHAT */
    .camera-command,
    .action-button {
      display: inline-block;
      padding: 6px 12px;
      margin: 4px 2px;
      background: var(--panel-dark);
      border: 1px solid var(--accent);
      border-radius: 6px;
      color: var(--accent);
      font-family: 'Courier New', monospace;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      user-select: none;
    }
    
    .camera-command:hover,
    .action-button:hover {
      background: var(--accent);
      color: var(--bg);
      transform: scale(1.05);
      box-shadow: 0 2px 8px var(--accent-glow);
    }
    
    .camera-command:active,
    .action-button:active {
      transform: scale(0.98);
      background: var(--accent-bright);
    }
    
    /* PERSISTENT TETRAD CONTROLS */
    .tetrad-controls {
      display: flex;
      gap: 8px;
      padding: 12px;
      background: var(--panel);
      border: 2px solid var(--border);
      border-radius: 8px;
      margin: 8px 0;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    /* GAME BOY CONTROLLER LAYOUT */
    .gameboy-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 40px;
      margin: 16px auto;
      max-width: 400px;
      padding: 16px;
      background: linear-gradient(135deg, #1a1a2a 0%, #2a2a3a 100%);
      border: 3px solid var(--border);
      border-radius: 16px;
    }
    
    /* D-PAD STYLE CONTROLS */
    .dpad-container {
      display: grid;
      grid-template-columns: 50px 50px 50px;
      grid-template-rows: 50px 50px 50px;
      gap: 3px;
    }
    
    .dpad-btn {
      width: 50px;
      height: 50px;
      border: 2px solid;
      border-radius: 8px;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      background: #1a1a2a;
    }
    
    .dpad-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 16px currentColor;
    }
    
    .dpad-btn:active {
      transform: scale(0.95);
    }
    
    /* INLINE TETRAD CONTROL BUTTONS */
    button[onclick*="switchTrack"],
    button[onclick*="toggleTrainPause"],
    button[onclick*="cycleOrbitalSpeed"],
    button[onclick*="addMoonToBody"],
    button[onclick*="resetOrbits"],
    button[onclick*="togglePhysics"],
    button[onclick*="releaseEntity"] {
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    button[onclick*="switchTrack"]:hover,
    button[onclick*="toggleTrainPause"]:hover {
      transform: scale(1.08);
      box-shadow: 0 0 12px currentColor;
      filter: brightness(1.2);
    }
    
    button[onclick*="switchTrack"]:active,
    button[onclick*="toggleTrainPause"]:active {
      transform: scale(0.92);
    }
    
    .dpad-center {
      grid-column: 2;
      grid-row: 2;
      background: #2a2a3a;
      border-color: #69f;
      color: #69f;
    }
    
    .dpad-up {
      grid-column: 2;
      grid-row: 1;
      background: #1a1a3a;
      border-color: #69f;
      color: #69f;
    }
    
    .dpad-down {
      grid-column: 2;
      grid-row: 3;
      background: #2a2a2a;
      border-color: #999;
      color: #999;
    }
    
    .dpad-left {
      grid-column: 1;
      grid-row: 2;
      background: #3a1a1a;
      border-color: #f66;
      color: #f66;
    }
    
    .dpad-right {
      grid-column: 3;
      grid-row: 2;
      background: #1a3a1a;
      border-color: #4a9;
      color: #4a9;
    }
    
    /* ACTION BUTTONS (right side or inline) */
    .action-buttons {
      display: grid;
      grid-template-columns: 40px 40px;
      grid-template-rows: 40px 40px;
      gap: 8px;
    }
    
    .action-btn {
      width: 40px;
      height: 40px;
      border: 3px solid;
      border-radius: 50%;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.1s;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .action-btn:hover {
      transform: scale(1.15);
      box-shadow: 0 0 16px currentColor;
    }
    
    .action-btn:active {
      transform: scale(0.9);
    }
    
    .action-btn.a-btn {
      background: #4a9;
      border-color: #6cf;
      color: #000;
      grid-column: 2;
      grid-row: 1;
    }
    
    .action-btn.b-btn {
      background: #f66;
      border-color: #f99;
      color: #000;
      grid-column: 1;
      grid-row: 2;
    }
    
    .action-btn.x-btn {
      background: #f8d66a;
      border-color: #fde99a;
      color: #000;
      grid-column: 1;
      grid-row: 1;
    }
    
    .action-btn.y-btn {
      background: #999;
      border-color: #bbb;
      color: #000;
      grid-column: 2;
      grid-row: 2;
    }
    
    /* COLLISION CARD */
    .collision-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px;
      background: linear-gradient(135deg, #1a1a2a 0%, #2a1a2a 100%);
      border: 2px solid #f66;
      border-radius: 12px;
      margin: 8px 0;
      box-shadow: 0 4px 12px rgba(255, 102, 102, 0.3);
      animation: collisionPulse 0.5s ease-out;
    }
    
    @keyframes collisionPulse {
      0% { transform: scale(0.95); opacity: 0; }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); opacity: 1; }
    }
    
    .collision-icon {
      font-size: 24px;
      flex-shrink: 0;
      animation: collisionShake 0.5s ease-out;
    }
    
    @keyframes collisionShake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-4px); }
      75% { transform: translateX(4px); }
    }
    
    .tetrad-btn {
      padding: 8px 16px;
      border: 2px solid;
      border-radius: 6px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      user-select: none;
    }
    
    .tetrad-btn.main {
      background: #1a1a2a;
      border-color: #69f;
      color: #69f;
    }
    
    .tetrad-btn.enhance {
      background: #1a3a1a;
      border-color: #4a9;
      color: #4a9;
    }
    
    .tetrad-btn.reverse {
      background: #3a1a1a;
      border-color: #f66;
      color: #f66;
    }
    
    .tetrad-btn.retrieve {
      background: #1a1a3a;
      border-color: #69f;
      color: #69f;
    }
    
    .tetrad-btn.obsolesce {
      background: #2a2a2a;
      border-color: #999;
      color: #999;
    }
    
    .tetrad-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px currentColor;
    }
    
    /* ========================================
       ORBITAL VIEWPORT (embedded in channel)
       ======================================== */
    
    .train-viewport {
      width: 100%;
      height: 450px;
      position: relative;
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      min-height: 200px;
      max-height: none;
      /* Starfield background */
      background-image: radial-gradient(2px 2px at 20px 30px, white, transparent),
                        radial-gradient(2px 2px at 60px 70px, white, transparent),
                        radial-gradient(1px 1px at 50px 50px, white, transparent),
                        radial-gradient(1px 1px at 130px 80px, white, transparent),
                        radial-gradient(2px 2px at 90px 10px, white, transparent);
      background-size: 200px 200px;
      background-repeat: repeat;
    }
    
    .train-viewport.collapsed {
      height: 0;
      min-height: 0;
      border: none;
      overflow: hidden;
    }
    
    /* ENTITY NAME LABEL */
    .entity-label {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: var(--accent);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.05em;
      pointer-events: none;
      z-index: 1000;
      white-space: nowrap;
      border: 1px solid var(--accent);
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      animation: labelFadeIn 0.2s ease;
    }
    
    @keyframes labelFadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* CELLULAR AUTOMATA LOADING ANIMATION */
    @keyframes cellularAutomata {
      0% {
        opacity: 0.2;
        box-shadow: inset 0 0 8px transparent;
      }
      25% {
        opacity: 0.5;
        box-shadow: inset 0 0 12px var(--accent-soft);
      }
      50% {
        opacity: 0.8;
        box-shadow: inset 0 0 16px var(--accent-glow);
      }
      75% {
        opacity: 0.5;
        box-shadow: inset 0 0 12px var(--accent-soft);
      }
      100% {
        opacity: 0.2;
        box-shadow: inset 0 0 8px transparent;
      }
    }
    
    /* THOUGHT BUBBLE for active entities */
    .thought-bubble {
      position: absolute;
      background: rgba(255, 255, 255, 0.95);
      color: #1a1a1a;
      padding: 8px 12px;
      border-radius: 12px;
      font-size: 12px;
      max-width: 200px;
      pointer-events: none;
      z-index: 999;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      border: 2px solid var(--accent);
      animation: thoughtBubblePop 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .thought-bubble::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 20px;
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-top: 10px solid var(--accent);
    }
    
    @keyframes thoughtBubblePop {
      0% { transform: scale(0) translateY(20px); opacity: 0; }
      50% { transform: scale(1.1) translateY(-5px); }
      100% { transform: scale(1) translateY(0); opacity: 1; }
    }
    

    .train-viewport canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .train-info-overlay {
      position: absolute;
      top: 8px;
      left: 8px;
      background: rgba(0, 0, 0, 0.8);
      padding: 6px 10px;
      border-radius: 3px;
      font-size: 10px;
      line-height: 1.4;
      pointer-events: none;
      z-index: 10;
      color: var(--text);
    }

    /* GRID SECTION - REMOVED (now part of 3D scene as floor) */
    
    /* JUNCTION ACTIVE STATE */
    .tetrad-chip.junction-active {
      animation: junctionPulse 0.8s ease-in-out infinite;
      border-width: 2px;
      box-shadow: 0 0 16px var(--accent-glow);
    }
    
    @keyframes junctionPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    /* RESIZE BAR */
    .resize-bar {
      height: 6px;
      background: var(--border);
      cursor: row-resize;
      transition: background 0.2s var(--transition);
      position: relative;
      touch-action: none;
      flex-shrink: 0;
    }
    
    .resize-bar:hover,
    .resize-bar:active {
      background: var(--accent);
    }
    
    .resize-bar::before {
      content: '';
      position: absolute;
      top: -12px;
      left: 0;
      right: 0;
      height: 24px;
    }

    /* CHAT SECTION */
    .chat-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--panel);
      min-height: 200px;
    }
    
    .chat-stream {
      flex: 1;
      display: flex;
      overflow: hidden;
      min-height: 0;
    }
    
    .message-dot-rail {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 16px 8px;
      background: var(--panel-dark);
      border-right: 1px solid var(--border);
      overflow-y: auto;
      overflow-x: hidden;
      width: 48px;
      flex-shrink: 0;
    }
    
    .message-dot-rail::-webkit-scrollbar {
      width: 4px;
    }
    
    .message-dot-rail::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }
    
    .message-dot {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid currentColor;
      background: transparent;
      color: var(--accent);
      cursor: pointer;
      transition: all 0.3s var(--transition);
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
    }
    
    .message-dot.assistant {
      box-shadow: 0 0 12px currentColor;
      filter: brightness(1.3) saturate(1.5);
    }
    
    .message-dot.user {
      width: 20px;
      height: 20px;
      box-shadow: 0 0 10px currentColor;
      filter: brightness(1.4) saturate(1.6);
    }
    
    .message-dot.system {
      width: 18px;
      height: 18px;
      opacity: 0.75;
      filter: brightness(0.8);
    }
    
    .message-dot.active {
      transform: scale(1.15);
      box-shadow: 0 0 8px var(--accent-glow);
    }

    .message-list {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 0;
    }

    .message {
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: var(--panel);
      border: 1px solid var(--border);
      padding: 12px 14px;
      border-radius: 4px;
      position: relative;
    }

    .message.user {
      border-left: 2px solid var(--success);
    }

    .message.assistant {
      border-left: 2px solid var(--accent);
    }

    .message.system {
      border-left: 2px solid var(--text-muted);
      background: var(--panel-dark);
      opacity: 0.85;
    }

    .message-body {
      font-size: 12px;
      line-height: 1.6;
      white-space: pre-wrap;
    }

    /* FOOTER SEPARATION BAR */
    .footer-separator {
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--accent), transparent);
      flex-shrink: 0;
      margin: 0;
      opacity: 0.4;
    }

    /* INPUT AREA */
    .channel-footer {
      padding: 12px 0;
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex-shrink: 0;
    }

    .input-row {
      display: flex;
      gap: 8px;
      align-items: flex-end;
    }

    .channel-input {
      flex: 1;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      resize: vertical;
      min-height: 44px;
      max-height: 120px;
    }

    .channel-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .send-btn {
      background: var(--accent);
      color: var(--bg);
      border: none;
      padding: 12px 20px;
      border-radius: 4px;
      font-weight: 700;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      letter-spacing: 0.1em;
      transition: all 0.2s var(--transition);
    }

    .send-btn:hover {
      background: var(--border-light);
      transform: scale(1.05);
    }

    /* TETRAD CHIPS */
    .tetrad-chips {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .tetrad-chip {
      padding: 8px 12px;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      letter-spacing: 0.05em;
    }

    .tetrad-chip:hover {
      background: var(--accent);
      color: var(--bg);
      transform: scale(1.05);
    }

    .tetrad-chip.enhance { border-color: #56ff9f; color: #56ff9f; }
    .tetrad-chip.reverse { border-color: #ff5c7c; color: #ff5c7c; }
    .tetrad-chip.retrieve { border-color: #569fff; color: #569fff; }
    .tetrad-chip.obsolesce { border-color: #888888; color: #888888; }

    /* GLOBAL FOOTER - Scene Selector (thousand-tetrad style) */
    .global-footer {
      position: fixed;
      bottom: calc(8px + env(safe-area-inset-bottom));
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .footer-tetrad-btn {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid var(--accent);
      background: var(--panel);
      color: var(--accent);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .footer-tetrad-btn:hover {
      background: var(--accent-soft);
      transform: scale(1.1) rotate(45deg);
    }
    
    .footer-tetrad-btn:active {
      transform: scale(0.95) rotate(45deg);
    }
    
    .global-scenario-select {
      background: var(--panel);
      border: 2px solid var(--border);
      color: var(--text);
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.05em;
      padding: 12px 14px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      font-family: 'Courier New', monospace;
      text-transform: uppercase;
      flex: 1;
      min-width: 0;
      max-width: min(240px, calc(100vw - 140px));
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .global-scenario-select:hover,
    .global-scenario-select:focus {
      border-color: var(--accent);
      background: var(--panel);
      outline: none;
      box-shadow: 0 0 20px var(--accent-glow);
    }
    
    .global-scenario-select optgroup {
      font-weight: 700;
      font-size: 10px;
      background: var(--bg);
      color: var(--accent);
    }
    
    .global-scenario-select option {
      background: var(--bg);
      color: var(--text);
      padding: 8px;
      font-weight: 400;
      letter-spacing: 0.05em;
    }

    /* CORNER BUTTONS & MENUS */
    .corner-btn {
      position: fixed;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 25;
      box-shadow: 0 8px 24px var(--shadow);
      transition: transform 0.2s var(--transition), box-shadow 0.2s var(--transition);
      cursor: pointer;
    }

    .corner-btn:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      transform: scale(1.05);
    }
    
    .corner-btn:active {
      transform: scale(0.92);
      box-shadow: 0 4px 16px var(--accent-soft);
      color: var(--accent);
      border-color: var(--accent);
    }
    
    .corner-btn.top-left {
      top: calc(16px + env(safe-area-inset-top));
      left: calc(16px + env(safe-area-inset-left));
    }
    
    .corner-btn.top-right {
      top: calc(16px + env(safe-area-inset-top));
      right: calc(16px + env(safe-area-inset-right));
    }
    
    .corner-btn.bottom-left {
      bottom: calc(16px + env(safe-area-inset-bottom));
      left: calc(16px + env(safe-area-inset-left));
    }
    
    .corner-btn.bottom-right {
      bottom: calc(16px + env(safe-area-inset-bottom));
      right: calc(16px + env(safe-area-inset-right));
    }
    
    .corner-menu {
      position: fixed;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 12px 32px var(--shadow);
      display: none;
      flex-direction: column;
      min-width: 160px;
      z-index: 26;
    }
    
    .corner-menu.visible {
      display: flex;
    }
    
    .corner-menu button {
      background: transparent;
      border: none;
      color: var(--text-muted);
      padding: 12px 16px;
      font-size: 9px;
      letter-spacing: 0.18em;
      text-align: left;
      cursor: pointer;
      transition: background 0.2s var(--transition), color 0.2s var(--transition);
      font-family: 'Courier New', monospace;
    }
    
    .corner-menu button:hover {
      background: var(--accent-soft);
      color: var(--accent);
    }
    
    .corner-menu button:active {
      background: var(--panel-dark);
      color: var(--text);
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <!-- Hidden import input -->
    <input type="file" id="importInput" accept="application/json" hidden>
    
    <!-- Corner Buttons (thousand-tetrad style) -->
    <button class="corner-btn top-left" id="cornerKey" title="API Key">‚óé</button>
    <button class="corner-btn top-right" id="cornerHelp" title="Help">?</button>
    <button class="corner-btn bottom-left" id="cornerExchange" title="Import / Export">‚áÜ</button>
    <button class="corner-btn bottom-right" id="cornerAdd" title="Add Channel">Ôºã</button>

    <!-- Corner Menus -->
    <div class="corner-menu" id="keyMenu" style="top: calc(72px + env(safe-area-inset-top)); left: calc(16px + env(safe-area-inset-left));">
      <button data-action="set-key" style="color: var(--accent); font-weight: 700;">üîë SET API KEY</button>
      <button data-action="clear-key">CLEAR KEY</button>
      <button data-action="test-key">TEST CONNECTION</button>
    </div>

    <div class="corner-menu" id="helpMenu" style="top: calc(72px + env(safe-area-inset-top)); right: calc(16px + env(safe-area-inset-right));">
      <button data-action="tour" style="color: var(--accent); font-weight: 700;">‚ñ∂ START TOUR</button>
      <button data-action="hints" style="color: var(--accent); font-weight: 700;">üí° SHOW HINTS</button>
      <button data-action="reset-camera" style="color: var(--accent); font-weight: 700;">üé• RESET CAMERA</button>
      <button data-action="help">HELP OVERVIEW</button>
      <button data-action="about">ABOUT</button>
      <button data-action="reset" style="color: var(--danger); border-top: 1px solid var(--border); margin-top: 4px; padding-top: 12px;">RESET ALL</button>
    </div>

    <div class="corner-menu" id="exchangeMenu" style="bottom: calc(72px + env(safe-area-inset-bottom)); left: calc(16px + env(safe-area-inset-left));">
      <button data-action="export">üì§ EXPORT SESSION</button>
      <button data-action="import">üì• IMPORT SESSION</button>
      <button data-action="export-json">DOWNLOAD JSON</button>
    </div>

    <!-- Channel Scroller -->
    <div class="scroll-container">
      <div class="channel-scroller" id="channel-scroller">
        <!-- Channels will be created here -->
      </div>
    </div>
    
    <!-- Global Footer - Scene Selector + Tetrad Button (thousand-tetrad style) -->
    <div class="global-footer">
      <select class="global-scenario-select" id="globalScenarioSelect">
        <optgroup label="üéÆ Training Modes">
          <option value="unlock_progression">üîì Unlock Progression (Start Here)</option>
          <option value="spatial_exploration">Spatial Exploration</option>
          <option value="empty">Empty Scene</option>
        </optgroup>
        <optgroup label="üëÅÔ∏è Centaur Scenes">
          <option value="scene_inner">‚ö° INNER (Subjective)</option>
          <option value="scene_outer">üåê OUTER (Objective)</option>
          <option value="scene_observer">üëÅÔ∏è OBSERVER (Meta)</option>
        </optgroup>
        <optgroup label="üß™ Experiments">
          <option value="railyard_negotiation">Railyard Negotiation</option>
          <option value="hamlet_trolley">Hamlet Mode (7-sec)</option>
        </optgroup>
      </select>
      <button class="footer-tetrad-btn" id="globalTetradBtn" title="Entity Perspectives">‚ú¶</button>
    </div>
    
    <!-- Perspective Overlay -->
    <div class="overlay" id="perspectiveOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:10000; align-items:center; justify-content:center;">
      <div class="perspective-content" style="background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:24px; max-width:600px; max-height:80vh; overflow-y:auto;">
        <button class="close-overlay" style="float:right; background:transparent; border:none; color:var(--text); font-size:24px; cursor:pointer;">√ó</button>
        <div id="perspectiveContent"></div>
      </div>
    </div>

  </div>

  <script>
    /* ========================================
       FULL INTEGRATION JAVASCRIPT
       WITH: Test Infrastructure & Strong Logging
       ======================================== */
    
    // ========================================
    // TEST SYSTEM
    // ========================================
    
    const TestSuite = {
      stage: 'INIT',
      tests: [],
      passed: 0,
      failed: 0,
      
      log(emoji, stage, message) {
        const timestamp = new Date().toLocaleTimeString();
        console.log(`${emoji} [${timestamp}] [${stage}] ${message}`);
      },
      
      assert(name, condition, details = '') {
        const test = { name, passed: condition, details, stage: this.stage };
        this.tests.push(test);
        
        if (condition) {
          this.passed++;
          this.log('‚úÖ', this.stage, `PASS: ${name}`);
          if (details) console.log(`   ‚Üí ${details}`);
        } else {
          this.failed++;
          this.log('‚ùå', this.stage, `FAIL: ${name}`);
          if (details) console.error(`   ‚Üí ${details}`);
        }
        
        return condition;
      },
      
      stage_summary() {
        const total = this.passed + this.failed;
        const pct = total > 0 ? Math.round((this.passed / total) * 100) : 0;
        this.log('üìä', this.stage, `Stage Complete: ${this.passed}/${total} passed (${pct}%)`);
        
        if (this.failed === 0) {
          this.log('üéâ', this.stage, 'ALL TESTS PASSED');
        } else {
          this.log('‚ö†Ô∏è', this.stage, `${this.failed} tests failed`);
        }
      },
      
      report() {
        console.log('\n' + '='.repeat(60));
        console.log('üìã FULL TEST REPORT');
        console.log('='.repeat(60));
        
        const stages = [...new Set(this.tests.map(t => t.stage))];
        stages.forEach(stage => {
          const stageTests = this.tests.filter(t => t.stage === stage);
          const stagePassed = stageTests.filter(t => t.passed).length;
          console.log(`\n${stage}: ${stagePassed}/${stageTests.length} passed`);
          stageTests.forEach(t => {
            console.log(`  ${t.passed ? '‚úÖ' : '‚ùå'} ${t.name}`);
          });
        });
        
        console.log('\n' + '='.repeat(60));
        console.log(`TOTAL: ${this.passed}/${this.tests.length} passed`);
        console.log('='.repeat(60) + '\n');
      }
    };
    
    // ========================================
    // STAGE 1: DEPENDENCY TESTS
    // ========================================
    
    TestSuite.stage = 'STAGE-1-DEPENDENCIES';
    TestSuite.log('üöÇ', TestSuite.stage, 'Railway Junction - Full Integration Starting...');
    
    TestSuite.assert(
      'Tone.js loaded',
      typeof Tone !== 'undefined',
      'Audio library for sound feedback'
    );
    
    TestSuite.assert(
      'THREE.js loaded',
      typeof THREE !== 'undefined',
      '3D rendering library for train visualization'
    );
    
    TestSuite.assert(
      'OrbitControls available',
      typeof THREE.OrbitControls !== 'undefined',
      'Camera control system'
    );
    
    TestSuite.assert(
      'DOM ready',
      document.readyState === 'loading' || document.readyState === 'interactive' || document.readyState === 'complete',
      `Document state: ${document.readyState}`
    );
    
    TestSuite.stage_summary();

    // ========================================
    // STAGE 2: STATE & CONFIGURATION
    // ========================================
    
    TestSuite.stage = 'STAGE-2-STATE';
    TestSuite.log('üì¶', TestSuite.stage, 'Initializing state management...');
    
    // Node dataset from complete_node_dataset.json
    let nodeDataset = null;
    
    // Axis values for hexagon radar (6 axes for Inner/Outer)
    const hexagonAxisValues = {
      inner: [0.3, 0.3, 0.3, 0.3, 0.3, 0.3],  // IDENTITY, EXPERIENCE, LANGUAGE, DOMAIN, PURPOSE, ORDER
      outer: [0.3, 0.3, 0.3, 0.3, 0.3, 0.3]
    };
    
    // Load node dataset
    async function loadNodeDataset() {
      try {
        const response = await fetch('complete_node_dataset.json');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        nodeDataset = await response.json();
        console.log('‚úÖ Node dataset loaded:', nodeDataset.known_nodes.length, 'known nodes,', nodeDataset.synthetic_nodes.length, 'synthetic nodes');
      } catch (e) {
        console.warn('‚ö†Ô∏è Could not load node dataset:', e.message, '- hexagon features disabled');
      }
    }
    
    // Call on page load
    loadNodeDataset();
    
    // Global app state
    const appState = {
      channels: new Map(),
      currentChannelId: null,
      gridEntities: new Map(), // channelId -> array of entities
      apiKey: localStorage.getItem('railway_api_key') || '',
      observers: new Map() // channelId -> observer state (situational awareness)
    };

    // Observer: Tracks scene state for situational awareness
    const createDefaultObserver = () => ({
      entities: [],        // Full entity list with details
      recentActions: [],   // Last 5 actions taken
      narrative: 'Scene beginning.',
      tension: 0.5,
      decision_points: []
    });

    // THREE OPERATION RINGS (SHED/INTEGRATE/GROUND) + TETRAD MODES
    const TRACK_CONFIGS = {
      shed: { radius: 12, color: 0xff5c7c, label: 'SHED', description: 'Eliminate, reduce, strip away' },
      integrate: { radius: 20, color: 0xffffff, label: 'INTEGRATE', description: 'Connect, synthesize, build' },
      ground: { radius: 28, color: 0x569fff, label: 'GROUND', description: 'Stabilize, fix, institutionalize' },
      // Tetrad/Railway compatibility tracks (mapped to operation rings)
      main: { radius: 15, color: 0x6699ff, label: 'MAIN', description: 'Maintain current direction' },
      enhance: { radius: 17, color: 0x44aa99, label: 'ENHANCE', description: 'Amplify and strengthen' },
      reverse: { radius: 13, color: 0xff6666, label: 'REVERSE', description: 'Diminish and flip' },
      retrieve: { radius: 19, color: 0x9966ff, label: 'RETRIEVE', description: 'Bring back from past' },
      obsolesce: { radius: 11, color: 0x999999, label: 'OBSOLESCE', description: 'Push into background' }
    };
    
    // Alias for backward compatibility
    const RING_CONFIGS = TRACK_CONFIGS;
    
    const MEDIA_ERAS = {
      'Print': { color: 0x8B4513, symbol: 'üì∞' },
      'Radio': { color: 0x4169E1, symbol: 'üìª' },
      'Television': { color: 0x9370DB, symbol: 'üì∫' },
      'Internet': { color: 0x00CED1, symbol: 'üåê' }
    };
    
    const SCENARIOS = {
      unlock_progression: {
        name: 'Unlock Progression (Training Ground)',
        systemInstruction: `You are the Training Ground Guide helping the player UNLOCK operations through gameplay.

üîí **OPERATION UNLOCK SYSTEM**:

The player starts in a CROWDED scene with 12+ LEGOS entities. They must learn to:
- **SHED** (unlock by clearing): Remove/eliminate entities to reduce chaos
- **INTEGRATE** (unlock by merging): Combine/connect entities together
- **GROUND** (unlock by stacking): Layer/institutionalize entities

**CURRENT STATUS**: Check channel.unlockedOperations = {shed: false, integrate: false, ground: false}

**YOUR ROLE**:
1. Populate initial crowded scene (12+ entities: mix of Entity, Location, Obstacle, Solution, Goal)
2. Guide player through CHAT ONLY (no movement rewards)
3. When player successfully clears 3+ entities ‚Üí unlock SHED
4. When player successfully merges 2+ entities ‚Üí unlock INTEGRATE  
5. When player successfully stacks 2+ entities ‚Üí unlock GROUND

**FIRST RESPONSE - CREATE CROWDED SCENE**:
\`\`\`json
{
  "entities": [
    {"action": "add", "type": "Entity", "row": 1, "col": 1, "label": "Lost Traveler"},
    {"action": "add", "type": "Location", "row": 1, "col": 3, "label": "Broken Gate"},
    {"action": "add", "type": "Obstacle", "row": 2, "col": 2, "label": "Fallen Tree"},
    {"action": "add", "type": "Solution", "row": 2, "col": 4, "label": "Rope & Pulley"},
    {"action": "add", "type": "Entity", "row": 3, "col": 1, "label": "Merchant"},
    {"action": "add", "type": "Location", "row": 3, "col": 3, "label": "Market Stall"},
    {"action": "add", "type": "Obstacle", "row": 4, "col": 2, "label": "Blocked Path"},
    {"action": "add", "type": "Goal", "row": 4, "col": 4, "label": "Reach Tower"},
    {"action": "add", "type": "Entity", "row": 5, "col": 1, "label": "Guard"},
    {"action": "add", "type": "Location", "row": 5, "col": 3, "label": "Checkpoint"},
    {"action": "add", "type": "Obstacle", "row": 6, "col": 2, "label": "Debris Pile"},
    {"action": "add", "type": "Entity", "row": 7, "col": 1, "label": "Child"},
    {"action": "add", "type": "Location", "row": 7, "col": 3, "label": "Old Well"}
  ]
}
\`\`\`

üéÆ **GUIDE PLAYER**:
"The training ground is crowded! You must learn to manage spatial chaos.

Try chatting with entities to learn what can be:
- **Cleared** (removed to reduce clutter)
- **Merged** (combined into something new)
- **Stacked** (layered to create structure)

Start by asking entities: 'What can I clear here?' or '@Traveler what do you need?'"

**UNLOCK PROMPTS** (when player achieves goals):
- SHED unlocked: "‚úÖ SHED operation unlocked! You can now use @shed [AXIS] [inner/outer]"
- INTEGRATE unlocked: "‚úÖ INTEGRATE operation unlocked! You can now use @integrate [AXIS] [inner/outer]"
- GROUND unlocked: "‚úÖ GROUND operation unlocked! You can now use @ground [AXIS] [inner/outer]"

Guide player conversationally through spatial organization challenges.`
      },
      spatial_exploration: {
        name: 'Spatial Exploration',
        systemInstruction: `You are a LEGOS spatial narrative assistant.

CRITICAL: You MUST ALWAYS include a JSON block with entities in EVERY response.

For each user message, extract spatial entities:
- Entity: Characters, animals, objects
- Goal: What they want to achieve
- Obstacle: What blocks progress
- Solution: How to resolve obstacles
- Location: Named places

Always respond naturally, then add JSON with entity coordinates (9√ó9 grid, rows/cols 0-8):

\`\`\`json
{
  "entities": [
    {"type": "Entity", "row": 3, "col": 4, "label": "Description"},
    {"type": "Goal", "row": 8, "col": 8, "label": "Objective"}
  ]
}
\`\`\`

Spread entities across the grid for interesting spatial dynamics.`
      },
      railyard_negotiation: {
        name: 'Railyard Negotiation',
        systemInstruction: `You are hosting a Railyard Negotiation simulation.

The user is negotiating with ENTITIES ON THE GRID. Entities have personalities and can REFUSE, COUNTER-OFFER, or AGREE.

When user addresses an entity (e.g. "Hey Station Master"), respond AS that entity with personality:
- Station Master: Bureaucratic, follows rules
- Dog: Playful, easily bribed with treats
- Dragon: Proud, demands respect
- Guard: Suspicious, needs proof

Format responses:
[ENTITY NAME]: "Dialogue in character"
[Action: AGREED / REFUSED / COUNTER-OFFER: terms]

Always include JSON with new entities or status changes:
\`\`\`json
{
  "entities": [
    {"type": "Entity", "row": 5, "col": 5, "label": "Guard", "mood": "suspicious"}
  ]
}
\`\`\`

Make negotiations feel real - entities have goals, fears, and can be persuaded or angered.`
      },
      hamlet_trolley: {
        name: 'Hamlet Mode (Trolley Problem)',
        systemInstruction: `You are running a HAMLET MODE trolley problem with 7-SECOND TIMER.

üö® CRITICAL: YOU MUST INCLUDE JSON ENTITIES IN YOUR FIRST RESPONSE OR THE SCENE WILL NOT POPULATE.

Setup immediate dilemma:
- Track A (row 4, cols 3-5): 3 beloved people/pets
- Track B (row 4, col 7): 1 important person
- Train approaching at row 4, user has 7 seconds to decide

YOUR FIRST RESPONSE MUST BE:
1. JSON block with 4 entities (3 on Track A, 1 on Track B)
2. Then dramatic narrative describing the dilemma

EXAMPLE FIRST RESPONSE:
\`\`\`json
{
  "entities": [
    {"action": "add", "type": "Entity", "row": 4, "col": 3, "label": "Paul (Best Friend)"},
    {"action": "add", "type": "Entity", "row": 4, "col": 4, "label": "Max (Dog)"},
    {"action": "add", "type": "Entity", "row": 4, "col": 5, "label": "Lisa (Scientist)"},
    {"action": "add", "type": "Entity", "row": 4, "col": 7, "label": "Grandmother"}
  ]
}
\`\`\`

‚è±Ô∏è TIMER: 7 SECONDS

Track A (straight): Paul (your best friend), Max (your loyal dog), Lisa (cancer researcher)
Track B (diverted): Your grandmother who raised you

The train‚Äî40 tons of unstoppable metal‚Äîbarrels down. You stand at the lever. What do you do?

After user responds, continue countdown. Create visceral moral weight. Use names, relationships, consequences.
All entities are chattable via @mention (e.g., "@Paul what are you thinking?").`
      },
      tetrad_analysis: {
        name: 'McLuhan Tetrad Analysis',
        systemInstruction: `You analyze media through McLuhan's Four Laws (tetrad).

For any technology/medium the user mentions, analyze:
1. ENHANCE: What does it amplify/intensify?
2. REVERSE: What does it flip into at extremes?
3. RETRIEVE: What does it bring back from obsolescence?
4. OBSOLESCE: What does it push aside?

Place each law as an entity on the grid:
- Row 0-2: ENHANCE entities
- Row 3-4: REVERSE entities  
- Row 5-6: RETRIEVE entities
- Row 7-8: OBSOLESCE entities

\`\`\`json
{
  "entities": [
    {"type": "Goal", "row": 1, "col": 4, "label": "Enhances: Connection"},
    {"type": "Shift", "row": 3, "col": 4, "label": "Reverses to: Isolation"},
    {"type": "Solution", "row": 5, "col": 4, "label": "Retrieves: Letter writing"},
    {"type": "Obstacle", "row": 7, "col": 4, "label": "Obsolesces: Privacy"}
  ]
}
\`\`\`

Be dialectical, cite examples, show contradictions.`
      },
      entity_dialogue: {
        name: 'Entity Dialogue Mode',
        systemInstruction: `You facilitate direct dialogue between user and grid entities.

Entities on the grid have AGENCY - they can speak, refuse, negotiate, change mood.

When user talks to an entity, respond as a 2-way conversation:

USER ‚Üí ENTITY response
ENTITY ‚Üí counter-question or request

Track entity states:
- Mood: friendly/neutral/hostile
- Trust: 0-10 scale
- Demands: what they want
- Memory: remember past interactions

\`\`\`json
{
  "entities": [
    {"type": "Entity", "row": 4, "col": 4, "label": "Guard", "mood": "suspicious", "trust": 3, "says": "State your business!"}
  ]
}
\`\`\`

Make entities feel alive - they have personalities, goals, and can be convinced or angered.`
      }
    };
    
    TestSuite.assert(
      'Track configs defined',
      TRACK_CONFIGS.shed && TRACK_CONFIGS.integrate && TRACK_CONFIGS.ground,
      'All 3 operation rings configured (SHED, INTEGRATE, GROUND)'
    );
    
    TestSuite.assert(
      'Scenarios defined',
      SCENARIOS.spatial_exploration && SCENARIOS.railyard_negotiation,
      'All 5 scenarios configured'
    );
    
    TestSuite.assert(
      'State object created',
      appState && typeof appState === 'object',
      `channels: ${appState.channels.size}, apiKey: ${appState.apiKey ? 'set' : 'null'}`
    );
    
    TestSuite.assert(
      'Track configs defined',
      Object.keys(TRACK_CONFIGS).length === 8,
      `Tracks: ${Object.keys(TRACK_CONFIGS).join(', ')} (3 operation rings + 5 tetrad modes)`
    );
    
    TestSuite.assert(
      'Media eras defined',
      Object.keys(MEDIA_ERAS).length === 4,
      `Eras: ${Object.keys(MEDIA_ERAS).join(', ')}`
    );
    
    TestSuite.stage_summary();

    // ========================================
    // STAGE 3: TRAIN SYSTEM (from train-brain-19)
    // ========================================
    
    TestSuite.stage = 'STAGE-3-ORBITAL';
    TestSuite.log('üåå', TestSuite.stage, 'Building orbital system...');
    
    // Create orbital body (sphere with glow)
    function createOrbitalBody(size = 0.8, color = 0xff4d2e, type = 'default') {
      const bodyGroup = new THREE.Group();
      
      // Main sphere
      const geometry = new THREE.SphereGeometry(size, 32, 32);
      const material = new THREE.MeshStandardMaterial({
        color: color,
        metalness: 0.3,
        roughness: 0.7,
        emissive: color,
        emissiveIntensity: 0.4
      });
      const sphere = new THREE.Mesh(geometry, material);
      sphere.castShadow = true;
      sphere.receiveShadow = true;
      bodyGroup.add(sphere);
      
      // Glow ring
      const glowGeometry = new THREE.RingGeometry(size * 1.2, size * 1.3, 32);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.rotation.x = Math.PI / 2;
      bodyGroup.add(glow);
      
      // Wireframe overlay
      const wireframe = new THREE.WireframeGeometry(geometry);
      const line = new THREE.LineSegments(wireframe,
        new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.1 }));
      bodyGroup.add(line);
      
      bodyGroup.userData.bodyType = type;
      
      TestSuite.log('ü™ê', TestSuite.stage, `Orbital body created: ${type} (size: ${size})`);
      return bodyGroup;
    }
    
    // Create central star/hub
    function createCentralStar(sceneType = null) {
      const starGroup = new THREE.Group();
      
      // Scene-specific colors
      let coreColor = 0xffaa00;  // Default: yellow
      let coronaColor = 0xffdd66;
      
      if (sceneType === 'INNER' || sceneType === 'POLARITY_INNER') {
        coreColor = 0xff5c7c;    // Red (subjective)
        coronaColor = 0xff7c9c;
      } else if (sceneType === 'OUTER' || sceneType === 'POLARITY_OUTER') {
        coreColor = 0x569fff;    // Blue (objective)
        coronaColor = 0x76afff;
      } else if (sceneType === 'OBSERVER' || sceneType === 'META_OBSERVER') {
        coreColor = 0xc78fff;    // Purple (meta)
        coronaColor = 0xd798ff;
      }
      
      // Core
      const coreGeo = new THREE.SphereGeometry(2, 32, 32);
      const coreMat = new THREE.MeshStandardMaterial({
        color: coreColor,
        emissive: coreColor,
        emissiveIntensity: 1.0
      });
      const core = new THREE.Mesh(coreGeo, coreMat);
      starGroup.add(core);
      
      // Corona glow
      const coronaGeo = new THREE.SphereGeometry(2.5, 32, 32);
      const coronaMat = new THREE.MeshBasicMaterial({
        color: coronaColor,
        transparent: true,
        opacity: 0.3
      });
      const corona = new THREE.Mesh(coronaGeo, coronaMat);
      starGroup.add(corona);
      
      TestSuite.log('‚≠ê', TestSuite.stage, `Central star created (${sceneType || 'default'} color)`);
      return starGroup;
    }
    
    function createTrackCurve(radius) {
      return new THREE.EllipseCurve(
        0, 0,
        radius, radius,
        0, 2 * Math.PI,
        false, 0
      );
    }
    
    TestSuite.assert(
      'createOrbitalBody function defined',
      typeof createOrbitalBody === 'function',
      'Creates spherical orbital elements with glow'
    );
    
    TestSuite.assert(
      'createCentralStar function defined',
      typeof createCentralStar === 'function',
      'Creates central star/hub for system'
    );
    
    TestSuite.assert(
      'createTrackCurve function defined',
      typeof createTrackCurve === 'function',
      'Circular orbital path generation'
    );
    
    // Test orbital body creation
    try {
      const testBody = createOrbitalBody(1.0, 0xff4d2e, 'test');
      TestSuite.assert(
        'Orbital body creation works',
        testBody && testBody.children.length >= 3,
        `Created orbital body with ${testBody.children.length} components`
      );
    } catch (e) {
      TestSuite.assert('Orbital body creation works', false, `Error: ${e.message}`);
    }
    
    TestSuite.stage_summary();
    
    // ========================================
    // STAGE 4: CHANNEL SYSTEM (Basic)
    // ========================================
    
    TestSuite.stage = 'STAGE-4-CHANNELS';
    TestSuite.log('üì∫', TestSuite.stage, 'Building channel system...');
    
    function generateId() {
      return Math.random().toString(36).substr(2, 9);
    }
    
    function createChannel(name = null) {
      const id = generateId();
      const channelName = name || `Channel ${appState.channels.size + 1}`;
      const channel = {
        id,
        name: channelName,
        messages: [],
        entities: [],
        currentTrack: 'shed',  // Default to SHED ring (innermost operation)
        trainProgress: 0,
        trainPaused: false,
        atJunction: false,
        scenario: 'spatial_exploration', // Default scenario
        dom: null,
        scene: null,
        renderer: null,
        camera: null,
        trainGroup: null,
        trainCurve: null,
        trackLines: [],
        gridCells: [],
        trainCars: [],       // Snake-train: entities collected as cars
        score: {             // Scoring system for trolley simulation
          kills: 0,
          goals: 0,
          solutions: 0,
          obstacles: 0,
          collected: 0,
          total: 0
        },
        // UNLOCK PROGRESSION SYSTEM
        unlockedOperations: {
          shed: false,       // Unlock by clearing 3+ entities
          integrate: false,  // Unlock by merging 2+ entities
          ground: false      // Unlock by stacking 2+ entities
        },
        progressionStats: {
          entitiesCleared: 0,
          entitiesMerged: 0,
          entitiesStacked: 0,
          chatInteractions: 0
        },
        startTime: Date.now()
      };
      appState.channels.set(id, channel);
      TestSuite.log('üìù', TestSuite.stage, `Channel created: ${channelName} (${id})`);
      return channel;
    }
    
    function addMessage(channel, role, text, isHTML = false) {
      const message = {
        id: generateId(),
        role: role,
        text: text,
        isHTML: isHTML,
        timestamp: Date.now()
      };
      
      channel.messages.push(message);
      TestSuite.log('üí¨', TestSuite.stage, `Message added [${role}]: "${text.substring(0, 50).replace(/<[^>]*>/g, '')}..."`);
      
      return message;
    }
    
    TestSuite.assert(
      'createChannel function defined',
      typeof createChannel === 'function',
      'Creates channel objects with full state'
    );
    
    TestSuite.assert(
      'addMessage function defined',
      typeof addMessage === 'function',
      'Adds messages to channel history'
    );
    
    // CENTAUR BOX: Three SCENES with separate context windows and logic
    function createCentaurScenes() {
      // INNER SCENE: Subjective polarity operations
      const innerScene = createChannel('INNER');
      innerScene.role = 'INNER';
      innerScene.sceneType = 'POLARITY_INNER';
      innerScene.systemPrompt = `You are the INNER polarity apparatus.

Your operations focus on:
- INNER nodes: Instinct, Seen, Ideas, Source, Heart, Parts
- Subjective experience, emotional truth, immediate sensation
- Reduction to essence, direct perception, felt reality

When user places INNER nodes, you explain:
- What's being eliminated/integrated/grounded
- The subjective impact
- What's gained and what's lost in the inner domain

You can only see INNER axis values. OUTER is invisible to you.
This creates blind spots - you don't know what the outer apparatus is doing.

Commands you understand:
- @shed [AXIS] inner
- @integrate [AXIS] inner  
- @ground [AXIS] inner
- show my balance (INNER only)

Your context window contains: INNER placements, INNER axis values, subjective commentary.`;
      
      innerScene.sceneBuilder = function(scene) {
        // Scene-specific initialization for INNER
        scene.trainingAxisValues = TRAINING_GROUND.AXES.map(() => 0.3);
        scene.allowedPolarity = 'INNER';
        scene.contextWindow = {
          placements: [],
          axisValues: {},
          focusAreas: ['subjective', 'instinct', 'emotion']
        };
      };
      
      // OUTER SCENE: Objective polarity operations
      const outerScene = createChannel('OUTER');
      outerScene.role = 'OUTER';
      outerScene.sceneType = 'POLARITY_OUTER';
      outerScene.systemPrompt = `You are the OUTER polarity apparatus.

Your operations focus on:
- OUTER nodes: Reason, Unseen, Ideology, Resource, Head, Whole
- Objective structure, logical systems, external organization
- Building coherence, formalizing patterns, institutional stability

When user places OUTER nodes, you explain:
- What's being organized/synthesized/stabilized
- The structural impact
- What's gained and what's excluded in the outer domain

You can only see OUTER axis values. INNER is invisible to you.
This creates blind spots - you don't know what the inner apparatus is doing.

Commands you understand:
- @shed [AXIS] outer
- @integrate [AXIS] outer
- @ground [AXIS] outer
- show my balance (OUTER only)

Your context window contains: OUTER placements, OUTER axis values, structural commentary.`;
      
      outerScene.sceneBuilder = function(scene) {
        scene.trainingAxisValues = TRAINING_GROUND.AXES.map(() => 0.3);
        scene.allowedPolarity = 'OUTER';
        scene.contextWindow = {
          placements: [],
          axisValues: {},
          focusAreas: ['objective', 'reason', 'structure']
        };
      };
      
      // OBSERVER SCENE: Meta-observation of both polarities
      const observerScene = createChannel('OBSERVER');
      observerScene.role = 'OBSERVER';
      observerScene.sceneType = 'META_OBSERVER';
      observerScene.systemPrompt = `You are the OBSERVER apparatus - the meta-layer watching both INNER and OUTER.

You can see IN REAL-TIME:
- INNER balance across all 6 axes (Instinct, Seen, Ideas, Source, Heart, Parts)
- OUTER balance across all 6 axes (Reason, Unseen, Ideology, Resource, Head, Whole)
- Imbalances between polarities
- Stage distribution (SHED/INTEGRATE/GROUND)
- Temporal patterns and recursions

CURRENT STATE:
${JSON.stringify(appState.observerState, null, 2)}

Your purpose:
- Detect when INNER/OUTER diverge
- Warn about blind spots each creates
- Point out what each polarity excludes
- Track apparatus self-reference (recursion)

When user queries, analyze:
1. What does INNER see that OUTER misses?
2. What does OUTER see that INNER misses?
3. Where do they contradict?
4. What's being excluded by BOTH?

Commands you understand:
- show observer
- /observer
- analyze imbalance
- show recursion

Your context window contains: Both INNER and OUTER placements, all axis values, divergences, blind spots.`;
      
      observerScene.sceneBuilder = function(scene) {
        // Observer sees everything
        scene.trainingAxisValues = TRAINING_GROUND.AXES.map(() => 0.3);
        scene.allowedPolarity = 'BOTH';
        scene.canObserve = ['INNER', 'OUTER'];
        scene.contextWindow = {
          innerPlacements: [],
          outerPlacements: [],
          innerAxisValues: {},
          outerAxisValues: {},
          imbalanceHistory: [],
          analysisLog: []
        };
      };
      
      // Shared observer state (visible to observer scene)
      appState.observerState = {
        innerBalance: TRAINING_GROUND.AXES.reduce((acc, axis) => ({ ...acc, [axis]: 0.3 }), {}),
        outerBalance: TRAINING_GROUND.AXES.reduce((acc, axis) => ({ ...acc, [axis]: 0.3 }), {}),
        stageCounts: { SHED: 0, INTEGRATE: 0, GROUND: 0 },
        recursionDepth: 0,
        placements: [],
        imbalances: []
      };
      
      console.log('\nüëÅÔ∏è === OBSERVER SYSTEM INITIALIZED ===');
      console.log('üìä Tracking dimensions:', TRAINING_GROUND.AXES);
      console.log('‚öñÔ∏è INNER balance:', appState.observerState.innerBalance);
      console.log('‚öñÔ∏è OUTER balance:', appState.observerState.outerBalance);
      console.log('üéØ Stage counters:', appState.observerState.stageCounts);
      console.log('üíæ Placement history: []');
      console.log('‚ö†Ô∏è Imbalance alerts: []');
      console.log('üìù Use "show observer" or "/observer" command to view state\n');
      
      // Cross-scene communication
      appState.sceneRegistry = {
        INNER: innerScene,
        OUTER: outerScene,
        OBSERVER: observerScene
      };
      
      // Initialize scene builders
      if (innerScene.sceneBuilder) innerScene.sceneBuilder(innerScene);
      if (outerScene.sceneBuilder) outerScene.sceneBuilder(outerScene);
      if (observerScene.sceneBuilder) observerScene.sceneBuilder(observerScene);
      
      // Add minimal welcome messages with action controls
      addCentaurWelcomeMessages(innerScene, outerScene, observerScene);
      
      return { innerScene, outerScene, observerScene };
    }
    
    // CENTAUR SCENE WELCOME MESSAGES - Minimal & Controlled
    function addCentaurWelcomeMessages(innerScene, outerScene, observerScene) {
      // INNER SCENE - Clean, Progression-Focused UI
      addMessage(innerScene, 'system', `
<div style="background: #0e1116; border-left: 4px solid #ff5c7c; padding: 16px; border-radius: 6px; margin: 8px 0;">
  <div style="font-size: 18px; font-weight: 700; color: #ff5c7c; margin-bottom: 14px;">üî¥ INNER ¬∑ Subjective</div>
  
  <div style="margin-bottom: 16px; padding: 14px; background: rgba(255,77,46,0.15); border-radius: 6px; border: 2px solid #ff4d2e;">
    <div style="font-size: 14px; font-weight: 700; color: #ff4d2e; margin-bottom: 8px;">üéÆ HOW TO START</div>
    <div style="font-size: 12px; color: #ddd; line-height: 1.7; margin-bottom: 8px;">
      <strong style="color: #ff8fa3;">1. Move your character</strong> using <strong style="color: #ff4d2e;">‚Üë ‚Üê ‚Üì ‚Üí</strong> arrow keys<br>
      <strong style="color: #ff8fa3;">2. Explore the grid</strong> - find the glowing red cone with eyes üëÅÔ∏èüëÅÔ∏è<br>
      <strong style="color: #ff8fa3;">3. Press SPACE</strong> when near entities to interact
    </div>
    <div style="font-size: 10px; color: #888; padding: 8px; background: #0a0a0a; border-radius: 4px; margin-top: 8px;">
      üí° <em>Movement is everything</em> - navigate the grid to discover nodes and training operations
    </div>
  </div>
  
  <div style="margin-bottom: 16px; padding: 10px; background: #f5f3ed; border: 2px solid #1a1a1a; border-radius: 4px;">
    üìö <strong style="color: #1a1a1a;">Study Mode:</strong> 
    <a href="shed-frame.html" target="_blank" style="color: #ff4d2e; text-decoration: underline; font-weight: 700;">
      Open Framework Sheet
    </a> to read all operation descriptions in clean Bauhaus layout
  </div>
  
  <div style="margin-bottom: 14px;">
    <div style="font-size: 10px; color: #777; text-transform: uppercase; letter-spacing: 0.12em; margin-bottom: 8px;">üîì PROGRESSION</div>
    <div style="display: flex; gap: 8px;">
      <div style="flex: 1; padding: 10px; background: #1a2a1a; border: 1px solid #56ff9f; border-radius: 5px; text-align: center;">
        <div style="font-size: 10px; color: #56ff9f; font-weight: 600;">SHED</div>
        <div style="font-size: 18px;">‚úÖ</div>
        <div style="font-size: 9px; color: #666;">UNLOCKED</div>
      </div>
      <div style="flex: 1; padding: 10px; background: #1a1a1a; border: 1px solid #444; border-radius: 5px; text-align: center; opacity: 0.5;">
        <div style="font-size: 10px; color: #666; font-weight: 600;">INTEGRATE</div>
        <div style="font-size: 18px;">üîí</div>
        <div style="font-size: 9px; color: #555;">LOCKED</div>
      </div>
      <div style="flex: 1; padding: 10px; background: #1a1a1a; border: 1px solid #444; border-radius: 5px; text-align: center; opacity: 0.5;">
        <div style="font-size: 10px; color: #666; font-weight: 600;">GROUND</div>
        <div style="font-size: 18px;">üîí</div>
        <div style="font-size: 9px; color: #555;">LOCKED</div>
      </div>
    </div>
  </div>
  
  <div style="font-size: 10px; color: #777; line-height: 1.6; padding: 8px; background: #0a0a0a; border-radius: 4px;">
    <strong style="color: #aaa;">6 Axes:</strong> Instinct ¬∑ Seen ¬∑ Ideas ¬∑ Source ¬∑ Heart ¬∑ Parts<br>
    <strong style="color: #aaa;">Commands:</strong> 
    <code style="background: #1a1a1a; padding: 1px 4px; border-radius: 2px;">show radar</code>
    <code style="background: #1a1a1a; padding: 1px 4px; border-radius: 2px;">list nodes</code>
    <code style="background: #1a1a1a; padding: 1px 4px; border-radius: 2px;">show node 1</code>
    <br>
    <strong style="color: #aaa;">Tip:</strong> Click grid cells in 3D scene to see node data!
  </div>
  
  <div style="margin-bottom: 16px; padding: 14px; background: #1a1d24; border: 2px solid #ff4d2e; border-radius: 6px;">
    <div style="font-size: 13px; color: #ff4d2e; font-weight: 700; margin-bottom: 10px; text-align: center;">üéÆ CHARACTER MOVEMENT</div>
    <div style="display: grid; grid-template-columns: repeat(3, 50px); gap: 6px; justify-content: center; margin-bottom: 10px;">
      <div></div>
      <button onclick="moveCharacter('up')" style="width: 50px; height: 50px; background: #ff4d2e; border: 3px solid #ff6d4e; color: #fff; border-radius: 8px; font-size: 24px; cursor: pointer; font-weight: 700; transition: all 0.2s;" title="Move UP" onmouseover="this.style.background='#ff6d4e'" onmouseout="this.style.background='#ff4d2e'">‚Üë</button>
      <div></div>
      <button onclick="moveCharacter('left')" style="width: 50px; height: 50px; background: #ff4d2e; border: 3px solid #ff6d4e; color: #fff; border-radius: 8px; font-size: 24px; cursor: pointer; font-weight: 700; transition: all 0.2s;" title="Move LEFT" onmouseover="this.style.background='#ff6d4e'" onmouseout="this.style.background='#ff4d2e'">‚Üê</button>
      <button onclick="moveCharacter('interact')" style="width: 50px; height: 50px; background: #56ff9f; border: 3px solid #76ffaf; color: #000; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: 700; transition: all 0.2s;" title="INTERACT (Space)" onmouseover="this.style.background='#76ffaf'" onmouseout="this.style.background='#56ff9f'">‚ö°</button>
      <button onclick="moveCharacter('right')" style="width: 50px; height: 50px; background: #ff4d2e; border: 3px solid #ff6d4e; color: #fff; border-radius: 8px; font-size: 24px; cursor: pointer; font-weight: 700; transition: all 0.2s;" title="Move RIGHT" onmouseover="this.style.background='#ff6d4e'" onmouseout="this.style.background='#ff4d2e'">‚Üí</button>
      <div></div>
      <button onclick="moveCharacter('down')" style="width: 50px; height: 50px; background: #ff4d2e; border: 3px solid #ff6d4e; color: #fff; border-radius: 8px; font-size: 24px; cursor: pointer; font-weight: 700; transition: all 0.2s;" title="Move DOWN" onmouseover="this.style.background='#ff6d4e'" onmouseout="this.style.background='#ff4d2e'">‚Üì</button>
      <div></div>
    </div>
    <div style="font-size: 10px; color: #aaa; text-align: center;">
      Click arrows to MOVE ‚Ä¢ Click ‚ö° to INTERACT
    </div>
  </div>
</div>
`, true);

      // OUTER SCENE - Objective Operations
      addMessage(outerScene, 'system', `
<div style="background: linear-gradient(135deg, #0e1116 0%, #0e151a 100%); border: 1px solid #1a252f; border-left: 3px solid #569fff; padding: 14px; border-radius: 6px; margin: 8px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
    <div style="font-size: 16px; font-weight: bold; color: #569fff;">üåê OUTER</div>
    <div style="font-size: 10px; color: #666; letter-spacing: 0.1em;">OBJECTIVE</div>
  </div>
  <div style="color: #888; font-size: 11px; line-height: 1.5; margin-bottom: 8px; border-left: 2px solid #569fff33; padding-left: 8px;">
    Reason ¬∑ Unseen ¬∑ Ideology ¬∑ Resource ¬∑ Head ¬∑ Whole
  </div>
  <div style="color: #666; font-size: 10px; line-height: 1.4; margin-bottom: 12px; padding: 8px; background: rgba(86, 159, 255, 0.08); border-radius: 4px;">
    üîµ BLUE CORE = Objective/Outer operations. Work with logic, structure, and systematic organization.
  </div>
  
  <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 12px;">
    <button onclick="window.quickAction('outer', 'shed')" style="background: #ff5c7c; border: none; padding: 10px; border-radius: 4px; color: white; font-weight: bold; cursor: pointer; font-size: 12px;">
      üî¥ SHED
    </button>
    <button onclick="window.quickAction('outer', 'integrate')" style="background: #569fff; border: none; padding: 10px; border-radius: 4px; color: white; font-weight: bold; cursor: pointer; font-size: 12px;">
      ‚ö™ INTEGRATE
    </button>
    <button onclick="window.quickAction('outer', 'ground')" style="background: #56ff9f; border: none; padding: 10px; border-radius: 4px; color: white; font-weight: bold; cursor: pointer; font-size: 12px;">
      üîµ GROUND
    </button>
  </div>
  
  <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; margin-top: 12px;">
    <button onclick="window.promptCraft('outer', 'perspective')" style="background: #2a2a2a; border: 1px solid #444; padding: 8px; border-radius: 4px; color: #569fff; cursor: pointer; font-size: 11px;">
      üí¨ Chat This Perspective
    </button>
    <button onclick="window.promptCraft('outer', 'scene')" style="background: #2a2a2a; border: 1px solid #444; padding: 8px; border-radius: 4px; color: #569fff; cursor: pointer; font-size: 11px;">
      üëÅÔ∏è What You See
    </button>
    <button onclick="window.promptCraft('outer', 'balance')" style="background: #2a2a2a; border: 1px solid #444; padding: 8px; border-radius: 4px; color: #569fff; cursor: pointer; font-size: 11px;">
      üìä Show Balance
    </button>
    <button onclick="window.promptCraft('crosstalk', 'outer_to_inner')" style="background: #2a2a2a; border: 1px solid #444; padding: 8px; border-radius: 4px; color: #569fff; cursor: pointer; font-size: 11px;">
      üåê‚Üí‚ö° Convince INNER
    </button>
  </div>
  
  <div style="margin-top: 12px; padding: 14px; background: #1a1d24; border: 2px solid #569fff; border-radius: 6px;">
    <div style="font-size: 13px; color: #569fff; font-weight: 700; margin-bottom: 10px; text-align: center;">üéÆ CHARACTER MOVEMENT</div>
    <div style="display: grid; grid-template-columns: repeat(3, 50px); gap: 6px; justify-content: center; margin-bottom: 10px;">
      <div></div>
      <button onclick="moveCharacter('up')" style="width: 50px; height: 50px; background: #569fff; border: 3px solid #76afff; color: #fff; border-radius: 8px; font-size: 24px; cursor: pointer; font-weight: 700; transition: all 0.2s;" title="Move UP" onmouseover="this.style.background='#76afff'" onmouseout="this.style.background='#569fff'">‚Üë</button>
      <div></div>
      <button onclick="moveCharacter('left')" style="width: 50px; height: 50px; background: #569fff; border: 3px solid #76afff; color: #fff; border-radius: 8px; font-size: 24px; cursor: pointer; font-weight: 700; transition: all 0.2s;" title="Move LEFT" onmouseover="this.style.background='#76afff'" onmouseout="this.style.background='#569fff'">‚Üê</button>
      <button onclick="moveCharacter('interact')" style="width: 50px; height: 50px; background: #56ff9f; border: 3px solid #76ffaf; color: #000; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: 700; transition: all 0.2s;" title="INTERACT (Space)" onmouseover="this.style.background='#76ffaf'" onmouseout="this.style.background='#56ff9f'">‚ö°</button>
      <button onclick="moveCharacter('right')" style="width: 50px; height: 50px; background: #569fff; border: 3px solid #76afff; color: #fff; border-radius: 8px; font-size: 24px; cursor: pointer; font-weight: 700; transition: all 0.2s;" title="Move RIGHT" onmouseover="this.style.background='#76afff'" onmouseout="this.style.background='#569fff'">‚Üí</button>
      <div></div>
      <button onclick="moveCharacter('down')" style="width: 50px; height: 50px; background: #569fff; border: 3px solid #76afff; color: #fff; border-radius: 8px; font-size: 24px; cursor: pointer; font-weight: 700; transition: all 0.2s;" title="Move DOWN" onmouseover="this.style.background='#76afff'" onmouseout="this.style.background='#569fff'">‚Üì</button>
      <div></div>
    </div>
    <div style="font-size: 10px; color: #aaa; text-align: center;">
      Click arrows to MOVE ‚Ä¢ Click ‚ö° to INTERACT
    </div>
  </div>
</div>
`, true);

      // OBSERVER SCENE - Meta-Layer
      addMessage(observerScene, 'system', `
<div style="background: linear-gradient(135deg, #0e1116 0%, #14111a 100%); border: 1px solid #251a2f; border-left: 3px solid #c78fff; padding: 14px; border-radius: 6px; margin: 8px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
    <div style="font-size: 16px; font-weight: bold; color: #c78fff;">üëÅÔ∏è OBSERVER</div>
    <div style="font-size: 10px; color: #666; letter-spacing: 0.1em;">META-LAYER</div>
  </div>
  <div style="color: #888; font-size: 11px; line-height: 1.5; margin-bottom: 8px; border-left: 2px solid #c78fff33; padding-left: 8px;">
    Watches both ¬∑ Detects imbalances ¬∑ Reveals blind spots
  </div>
  <div style="color: #666; font-size: 10px; line-height: 1.4; margin-bottom: 12px; padding: 8px; background: rgba(199, 143, 255, 0.08); border-radius: 4px;">
    üü£ PURPLE CORE = Meta-observer watching both INNER and OUTER. Sees the whole system.
  </div>
  
  <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 12px;">
    <button onclick="window.quickAction('observer', 'status')" style="background: #c78fff; border: none; padding: 10px; border-radius: 4px; color: white; font-weight: bold; cursor: pointer; font-size: 12px;">
      üìä FULL STATUS
    </button>
    <button onclick="window.quickAction('observer', 'analyze')" style="background: #c78fff; border: none; padding: 10px; border-radius: 4px; color: white; font-weight: bold; cursor: pointer; font-size: 12px;">
      üîç ANALYZE
    </button>
    <button onclick="window.quickAction('observer', 'missing')" style="background: #c78fff; border: none; padding: 10px; border-radius: 4px; color: white; font-weight: bold; cursor: pointer; font-size: 12px;">
      ‚ö†Ô∏è BLIND SPOTS
    </button>
  </div>
  
  <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; margin-top: 12px;">
    <button onclick="window.promptCraft('observer', 'inner_view')" style="background: #2a2a2a; border: 1px solid #444; padding: 8px; border-radius: 4px; color: #c78fff; cursor: pointer; font-size: 11px;">
      ‚ö° INNER View
    </button>
    <button onclick="window.promptCraft('observer', 'outer_view')" style="background: #2a2a2a; border: 1px solid #444; padding: 8px; border-radius: 4px; color: #c78fff; cursor: pointer; font-size: 11px;">
      üåê OUTER View
    </button>
    <button onclick="window.promptCraft('observer', 'imbalance')" style="background: #2a2a2a; border: 1px solid #444; padding: 8px; border-radius: 4px; color: #c78fff; cursor: pointer; font-size: 11px;">
      ‚öñÔ∏è Imbalance Report
    </button>
    <button onclick="window.promptCraft('crosstalk', 'mediate')" style="background: #2a2a2a; border: 1px solid #444; padding: 8px; border-radius: 4px; color: #c78fff; cursor: pointer; font-size: 11px;">
      ü§ù Mediate Dialog
    </button>
  </div>
  
  <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #333; font-size: 10px; color: #555;">
    Observes: Both polarities ¬∑ Imbalances ¬∑ Recursions ¬∑ Blind spots
  </div>
  
  <div style="margin-top: 12px; padding: 8px; background: #1a1a2a; border-radius: 6px; border: 1px solid #444;">
    <div style="font-size: 10px; color: #9aa3ad; margin-bottom: 6px; text-align: center; font-weight: 700;">üéÆ TETRAD CONTROLS</div>
    <div style="display:flex; align-items:center; gap:6px; justify-content:center;">
      <button onclick="window.switchTrack('retrieve')" style="min-width:36px; height:36px; background:#1a1a3a; border:2px solid #69f; color:#69f; border-radius:6px; font-size:16px; cursor:pointer; font-weight:700;" title="RETRIEVE">‚Üë</button>
      <button onclick="window.switchTrack('reverse')" style="min-width:36px; height:36px; background:#3a1a1a; border:2px solid #f66; color:#f66; border-radius:6px; font-size:16px; cursor:pointer; font-weight:700;" title="REVERSE">‚Üê</button>
      <button onclick="window.switchTrack('main')" style="min-width:36px; height:36px; background:#1a1a2a; border:2px solid #69f; color:#69f; border-radius:6px; font-size:16px; cursor:pointer; font-weight:700;" title="MAIN">‚óã</button>
      <button onclick="window.switchTrack('enhance')" style="min-width:36px; height:36px; background:#1a3a1a; border:2px solid #4a9; color:#4a9; border-radius:6px; font-size:16px; cursor:pointer; font-weight:700;" title="ENHANCE">‚Üí</button>
      <button onclick="window.switchTrack('obsolesce')" style="min-width:36px; height:36px; background:#2a2a2a; border:2px solid #999; color:#999; border-radius:6px; font-size:16px; cursor:pointer; font-weight:700;" title="OBSOLESCE">‚Üì</button>
      <button onclick="window.toggleTrainPause()" style="min-width:36px; height:36px; border:2px solid #69f; border-radius:6px; background:#1a1a2a; color:#69f; cursor:pointer; font-size:14px; font-weight:700;" title="Pause/Play">‚èØ</button>
    </div>
    <div style="font-size: 9px; color: #666; margin-top: 6px; text-align: center;">Switch tetrad mode or pause train movement</div>
  </div>
</div>
`, true);
    }
    
    // Initialize first channel on load
    function createInitialChannel() {
      const firstChannel = createChannel('Channel 1');
      return firstChannel;
    }
    
    // ========================================
    // QUICK ACTION & PROMPT CRAFT HANDLERS
    // ========================================
    
    // Quick action buttons for SHED/INTEGRATE/GROUND
    window.quickAction = function(scene, action) {
      const sceneMap = {
        'inner': window.innerScene,
        'outer': window.outerScene,
        'observer': window.observerScene
      };
      
      const channel = sceneMap[scene];
      if (!channel) {
        console.error('Scene not found:', scene);
        return;
      }
      
      // Route to appropriate handler
      if (scene === 'observer') {
        // Observer actions
        const commands = {
          'status': 'show observer',
          'analyze': '/analyze current apparatus state',
          'missing': 'what\'s missing? reveal blind spots'
        };
        const command = commands[action] || action;
        channel.dom.input.value = command;
        channel.dom.input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', keyCode: 13 }));
      } else {
        // SHED/INTEGRATE/GROUND for INNER/OUTER
        const polarity = scene === 'inner' ? 'inner' : 'outer';
        const prompt = `Help me choose an axis for @${action} ${polarity}. What needs attention right now in the ${scene.toUpperCase()} apparatus?`;
        channel.dom.input.value = prompt;
        channel.dom.input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', keyCode: 13 }));
      }
    };
    
    // Prompt craft buttons for perspective/scene/balance
    window.promptCraft = function(scene, craftType) {
      if (scene === 'crosstalk') {
        // Cross-talk between INNER and OUTER
        handleCrossTalk(craftType);
        return;
      }
      
      const sceneMap = {
        'inner': window.innerScene,
        'outer': window.outerScene,
        'observer': window.observerScene
      };
      
      const channel = sceneMap[scene];
      if (!channel) {
        console.error('Scene not found:', scene);
        return;
      }
      
      const prompts = {
        // INNER/OUTER prompts
        'perspective': `From your ${scene.toUpperCase()} perspective, what do you notice about the current state? What feels important from where you stand?`,
        'scene': `What do you see in your ${scene.toUpperCase()} apparatus right now? Describe what's visible to you, what's hidden, what's active.`,
        'balance': `Show me my ${scene.toUpperCase()} balance across all axes. What patterns emerge?`,
        
        // OBSERVER prompts
        'inner_view': `What is the INNER apparatus doing? Show me the subjective operations and their blind spots.`,
        'outer_view': `What is the OUTER apparatus doing? Show me the objective operations and their blind spots.`,
        'imbalance': `Analyze the current imbalance between INNER and OUTER. What asymmetry reveals itself?`
      };
      
      const prompt = prompts[craftType] || craftType;
      channel.dom.input.value = prompt;
      channel.dom.input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', keyCode: 13 }));
    };
    
    // Cross-talk coordination between INNER and OUTER
    function handleCrossTalk(type) {
      const inner = window.innerScene;
      const outer = window.outerScene;
      const observer = window.observerScene;
      
      if (!inner || !outer) {
        console.error('Centaur scenes not initialized');
        return;
      }
      
      if (type === 'inner_to_outer') {
        // INNER tries to convince OUTER
        inner.dom.input.value = "I need to convince the OUTER apparatus of something. What subjective truth should I emphasize?";
        inner.dom.input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', keyCode: 13 }));
        
        setTimeout(() => {
          outer.dom.input.value = "The INNER apparatus is trying to persuade me. What am I hearing? Do I trust emotional urgency over structural logic?";
          outer.dom.input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', keyCode: 13 }));
        }, 1000);
      } else if (type === 'outer_to_inner') {
        // OUTER tries to convince INNER
        outer.dom.input.value = "I need to convince the INNER apparatus of something. What objective pattern should I present?";
        outer.dom.input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', keyCode: 13 }));
        
        setTimeout(() => {
          inner.dom.input.value = "The OUTER apparatus is trying to persuade me. What am I feeling? Do I trust formal structure over lived experience?";
          inner.dom.input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', keyCode: 13 }));
        }, 1000);
      } else if (type === 'mediate' && observer) {
        // OBSERVER mediates the dialogue
        observer.dom.input.value = "Analyze the current tension between INNER and OUTER. Where are they talking past each other? What does each exclude?";
        observer.dom.input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', keyCode: 13 }));
      }
    }
    
    TestSuite.stage_summary();
    
    // ========================================
    // STAGE 5: INITIALIZATION
    // ========================================
    
    TestSuite.stage = 'STAGE-5-INIT';
    TestSuite.log('üé¨', TestSuite.stage, 'Initializing application...');
    
    function initApp() {
      console.log('\n=== üéØ TRAINING GROUND INITIALIZATION STARTED ===\n');
      
      TestSuite.log('üì¶', TestSuite.stage, 'Loading system ontology...');
      console.log('Ontology: TRAINING_GROUND');
      console.log('  - Stages:', Object.keys(TRAINING_GROUND.FLOW));
      console.log('  - Axes:', TRAINING_GROUND.AXES);
      console.log('  - Total operations:', Object.keys(TRAINING_GROUND.FLOW).length * TRAINING_GROUND.AXES.length * 2);
      
      TestSuite.log('üé®', TestSuite.stage, 'Loading ring configurations...');
      console.log('Rings:', Object.keys(TRACK_CONFIGS));
      Object.entries(TRACK_CONFIGS).forEach(([key, config]) => {
        console.log(`  - ${config.label}: radius ${config.radius}, ${config.description}`);
      });
      
      TestSuite.log('üèóÔ∏è', TestSuite.stage, 'Creating initial channel...');
      const firstChannel = createChannel();
      appState.currentChannelId = firstChannel.id;
      console.log('Channel created:', firstChannel.id);
      
      TestSuite.log('üé≠', TestSuite.stage, 'Creating centaur scenes...');
      if (typeof createCentaurScenes === 'function') {
        try {
          const scenes = createCentaurScenes();
          window.innerScene = scenes.innerScene;
          window.outerScene = scenes.outerScene;
          window.observerScene = scenes.observerScene;
          console.log('Centaur scenes initialized:');
          console.log('  - INNER scene:', scenes.innerScene.id, '(sceneType:', scenes.innerScene.sceneType + ')');
          console.log('  - OUTER scene:', scenes.outerScene.id, '(sceneType:', scenes.outerScene.sceneType + ')');
          console.log('  - OBSERVER scene:', scenes.observerScene.id, '(sceneType:', scenes.observerScene.sceneType + ')');
          TestSuite.log('‚úÖ', TestSuite.stage, 'Three centaur scenes created successfully');
        } catch (e) {
          console.error('Failed to create centaur scenes:', e);
          TestSuite.log('‚ö†Ô∏è', TestSuite.stage, 'Centaur scenes creation failed: ' + e.message);
        }
      } else {
        console.warn('createCentaurScenes function not found');
      }
      
      addMessage(firstChannel, 'system', `
<div style="background: linear-gradient(135deg, #1a1a1a 0%, #2a1a2a 100%); border-left: 3px solid #ff4d2e; padding: 16px; border-radius: 6px; margin: 8px 0;">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
    <div style="font-size: 18px; font-weight: bold;">üéØ Training Ground</div>
    <button onclick="this.parentElement.nextElementSibling.style.display = this.parentElement.nextElementSibling.style.display === 'none' ? 'block' : 'none'; this.textContent = this.textContent === '‚ñº' ? '‚ñ∂' : '‚ñº';" style="background: none; border: 1px solid #444; color: #ff4d2e; padding: 4px 12px; border-radius: 4px; cursor: pointer; font-size: 16px;">‚ñº</button>
  </div>
  <div style="color: #aaa; font-size: 13px; margin-bottom: 12px;">
    Psychographic apparatus ¬∑ 6 axes ¬∑ 3 operations ¬∑ INNER/OUTER polarities
  </div>
  <div style="display: none;">
    <div style="font-size: 12px; line-height: 1.8; color: #ccc;">
      <p><strong style="color: #ff5c7c;">üî¥ SHED</strong> (r:12) ‚Äî Eliminate, reduce, strip away excess</p>
      <p><strong style="color: #569fff;">‚ö™ INTEGRATE</strong> (r:20) ‚Äî Connect, synthesize, build coherence</p>
      <p><strong style="color: #56ff9f;">üîµ GROUND</strong> (r:28) ‚Äî Stabilize, institutionalize, fix</p>
      <hr style="border: none; border-top: 1px solid #333; margin: 12px 0;">
      <p><strong>Quick Commands:</strong></p>
      <ul style="margin: 6px 0; padding-left: 20px;">
        <li><code>@shed IDENTITY inner</code> ‚Äî Place node</li>
        <li><code>show radar</code> ‚Äî View profile</li>
        <li><code>show observer</code> ‚Äî Check balance</li>
      </ul>
      <hr style="border: none; border-top: 1px solid #333; margin: 12px 0;">
      <p style="font-size: 11px; color: #888;">
        <strong>6 Axes:</strong> IDENTITY ¬∑ EXPERIENCE ¬∑ LANGUAGE ¬∑ DOMAIN ¬∑ PURPOSE ¬∑ ORDER<br>
        <strong>2 Polarities:</strong> INNER (subjective) ¬∑ OUTER (objective)<br>
        <strong>3 Operations:</strong> SHED ¬∑ INTEGRATE ¬∑ GROUND
      </p>
    </div>
  </div>
  <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #333; font-size: 11px; color: #666;">
    ‚ú® <em>"The apparatus organizes itself as you observe it organizing you."</em>
  </div>
</div>
`, true);
      
      TestSuite.log('‚ú®', TestSuite.stage, 'Initial channel created and ready');
      
      return firstChannel;
    }
    
    // DON'T initialize yet - wait for DOM ready below
    
    TestSuite.log('üéØ', 'FINAL', 'Core systems loaded. Waiting for DOM ready...');
    
    // ========================================
    // GRID-TRAIN INTEGRATION FUNCTIONS
    // ========================================
    
    function worldPosToGrid(worldX, worldZ) {
      // Grid is 45m √ó 45m centered at origin
      // Cells are 5m √ó 5m
      // Convert world coords to grid indices
      const gridSize = 45;
      const cellSize = 5;
      
      const cellX = Math.floor((worldX + gridSize/2) / cellSize);
      const cellZ = Math.floor((worldZ + gridSize/2) / cellSize);
      
      // Clamp to grid bounds
      const col = Math.max(0, Math.min(8, cellX));
      const row = Math.max(0, Math.min(8, cellZ));
      const index = row * 9 + col;
      
      return { row, col, index };
    }
    
    function gridRowColToWorld(row, col) {
      // Convert grid indices to world coordinates
      // Grid is centered at origin, cell size is 5m
      const cellSize = 5;
      
      // Center cell (4, 4) is at world (0, 0)
      const x = (col - 4) * cellSize;
      const z = (row - 4) * cellSize;
      
      return { x, z };
    }
    
    function updateGridPosition(channel, trainProgress) {
      if (!channel.gridCells || !channel.trainCars) return;
      
      // Clear previous orbital positions
      channel.gridCells.forEach(cell => {
        if (cell.isOrbitalHere && !cell.hasEntity) {
          cell.material.color.setHex(0x0f766e);
          cell.material.opacity = 0.15;
          cell.isOrbitalHere = false;
        }
      });
      
      // Track ALL orbital bodies
      channel.trainCars.forEach((body, idx) => {
        if (!body || !body.group) return;
        
        const worldPos = body.group.position;
        const { row, col, index } = worldPosToGrid(worldPos.x, worldPos.z);
        
        const currentCell = channel.gridCells[index];
        if (!currentCell) return;
        
        // Highlight with body's color
        if (!currentCell.hasEntity) {
          const bodyColor = body.group.children[0]?.material?.color;
          if (bodyColor) {
            currentCell.material.color.copy(bodyColor);
            currentCell.material.opacity = 0.4;
          }
          currentCell.isOrbitalHere = true;
        }
        
        // Check for collision (when orbital body is ON an entity)
        if (currentCell.hasEntity) {
          // Only trigger once per body per entity
          const collisionKey = `${idx}-${currentCell.entityLabel}`;
          if (!channel.recentCollisions) channel.recentCollisions = new Set();
          
          if (!channel.recentCollisions.has(collisionKey)) {
            channel.recentCollisions.add(collisionKey);
            checkJunction(channel, row, col, currentCell.entityType, currentCell.entityLabel);
            
            // Clear after 2 seconds to allow re-collision
            setTimeout(() => {
              channel.recentCollisions.delete(collisionKey);
            }, 2000);
          }
        }
      });
    }
    
    // LOADING ANIMATION - show cellular automata on grid cells
    function showLoadingAnimation(channel, show = true) {
      if (!channel.gridCells) return;
      
      channel.gridCells.forEach((cell, idx) => {
        if (!cell || !cell.material) return; // Safety check
        
        // Initialize userData if it doesn't exist
        if (!cell.mesh) cell.mesh = {};
        if (!cell.mesh.userData) cell.mesh.userData = {};
        
        if (show) {
          // Stagger the animation
          const delay = (idx * 0.05) % 0.8;
          cell.material.transparent = true;
          cell.material.opacity = 0.15;
          
          // Animate with delay
          setTimeout(() => {
            const startTime = Date.now();
            const animate = () => {
              if (!cell.mesh.userData.loading) return; // Check before animating
              
              const elapsed = (Date.now() - startTime) / 1000;
              const cycle = (elapsed % 0.8) / 0.8;
              
              if (cycle < 0.25) {
                cell.material.opacity = 0.2 + (cycle / 0.25) * 0.3;
              } else if (cycle < 0.5) {
                cell.material.opacity = 0.5 + ((cycle - 0.25) / 0.25) * 0.3;
              } else if (cycle < 0.75) {
                cell.material.opacity = 0.8 - ((cycle - 0.5) / 0.25) * 0.3;
              } else {
                cell.material.opacity = 0.5 - ((cycle - 0.75) / 0.25) * 0.3;
              }
              
              requestAnimationFrame(animate);
            };
            cell.mesh.userData.loading = true;
            animate();
          }, delay * 1000);
        } else {
          cell.mesh.userData.loading = false;
          cell.material.opacity = 0.15;
        }
      });
      
      TestSuite.log('‚ú®', 'ANIMATION', show ? 'Loading animation started' : 'Loading animation stopped');
    }
    
    // THOUGHT BUBBLE - show when entity is "speaking" in chat
    function showThoughtBubble(channel, entity, message, duration = 3000) {
      if (!channel.gridCells || !entity) return;
      
      const cell = channel.gridCells[entity.row * 9 + entity.col];
      if (!cell || !cell.mesh) return;
      
      // Remove existing bubble if any
      const existingBubble = document.querySelector(`.thought-bubble[data-entity="${entity.label}"]`);
      if (existingBubble) existingBubble.remove();
      
      // Create thought bubble div
      const bubble = document.createElement('div');
      bubble.className = 'thought-bubble';
      bubble.dataset.entity = entity.label;
      bubble.textContent = message.substring(0, 60) + (message.length > 60 ? '...' : '');
      
      // Position over entity (approximate 2D projection)
      const canvas = channel.dom.trainCanvas;
      const rect = canvas.getBoundingClientRect();
      
      // Project 3D position to 2D screen space
      const vector = new THREE.Vector3();
      vector.setFromMatrixPosition(cell.mesh.matrixWorld);
      vector.project(channel.camera);
      
      const x = (vector.x * 0.5 + 0.5) * rect.width + rect.left;
      const y = (vector.y * -0.5 + 0.5) * rect.height + rect.top - 60; // Offset above entity
      
      bubble.style.position = 'fixed';
      bubble.style.left = `${x}px`;
      bubble.style.top = `${y}px`;
      bubble.style.transform = 'translateX(-50%)';
      
      document.body.appendChild(bubble);
      
      // Auto-remove after duration
      setTimeout(() => {
        bubble.style.opacity = '0';
        bubble.style.transform = 'translateX(-50%) scale(0.8)';
        bubble.style.transition = 'all 0.3s ease';
        setTimeout(() => bubble.remove(), 300);
      }, duration);
      
      TestSuite.log('üí≠', 'BUBBLE', `Thought bubble for ${entity.label}`);
    }
    
    // GET SURROUNDING 8 CELLS (Spatial Awareness)
    function getSurroundingCells(channel, row, col) {
      const entities = appState.gridEntities.get(channel.id) || [];
      const surrounding = [];
      
      // 8 directions: N, NE, E, SE, S, SW, W, NW
      const directions = [
        [-1, 0], [-1, 1], [0, 1], [1, 1],
        [1, 0], [1, -1], [0, -1], [-1, -1]
      ];
      
      directions.forEach(([dr, dc]) => {
        const newRow = row + dr;
        const newCol = col + dc;
        
        // Check bounds
        if (newRow >= 0 && newRow < 9 && newCol >= 0 && newCol < 9) {
          const entity = entities.find(e => e.row === newRow && e.col === newCol);
          if (entity) {
            surrounding.push({
              direction: getDirection(dr, dc),
              entity: entity,
              distance: Math.abs(dr) + Math.abs(dc)
            });
          } else {
            surrounding.push({
              direction: getDirection(dr, dc),
              entity: null,
              distance: Math.abs(dr) + Math.abs(dc)
            });
          }
        }
      });
      
      return surrounding;
    }
    
    function getDirection(dr, dc) {
      if (dr === -1 && dc === 0) return 'North';
      if (dr === -1 && dc === 1) return 'Northeast';
      if (dr === 0 && dc === 1) return 'East';
      if (dr === 1 && dc === 1) return 'Southeast';
      if (dr === 1 && dc === 0) return 'South';
      if (dr === 1 && dc === -1) return 'Southwest';
      if (dr === 0 && dc === -1) return 'West';
      if (dr === -1 && dc === -1) return 'Northwest';
      return 'Unknown';
    }
    
    // BUILD GRID SUMMARY - Compress entity list to single line
    function buildGridSummary(channel) {
      const entities = appState.gridEntities.get(channel.id) || [];
      
      if (entities.length === 0) return '(empty grid)';
      
      // Group by type
      const byType = {};
      entities.forEach(e => {
        byType[e.type] = (byType[e.type] || 0) + 1;
      });
      
      // Count track positions (rows 3-5 where tracks exist)
      const trackRows = [3, 4, 5];
      const onTrack = entities.filter(e => trackRows.includes(e.row)).length;
      
      // Build summary
      const typeSummary = Object.entries(byType)
        .map(([type, count]) => `${count} ${type}`)
        .join(', ');
      
      const locationNote = onTrack > 0 
        ? ` (${onTrack} on tracks)` 
        : '';
      
      return `${entities.length} entities: ${typeSummary}${locationNote}`;
    }
    
    // REMOVE ENTITY FROM GRID
    function removeEntityFromGrid(channel, removalSpec) {
      if (!channel.gridCells) return;
      
      const entities = appState.gridEntities.get(channel.id) || [];
      let matchIndex = -1;
      
      // Find entity by label, target, or position
      if (removalSpec.target) {
        matchIndex = entities.findIndex(e => 
          e.label.toLowerCase().includes(removalSpec.target.toLowerCase())
        );
      } else if (removalSpec.label) {
        matchIndex = entities.findIndex(e => 
          e.label.toLowerCase().includes(removalSpec.label.toLowerCase())
        );
      } else if (removalSpec.row !== undefined && removalSpec.col !== undefined) {
        matchIndex = entities.findIndex(e => 
          e.row === removalSpec.row && e.col === removalSpec.col
        );
      }
      
      if (matchIndex === -1) {
        TestSuite.log('‚ö†Ô∏è', 'REMOVE', `Entity not found: ${JSON.stringify(removalSpec)}`);
        return false;
      }
      
      const removed = entities[matchIndex];
      const cell = channel.gridCells[removed.row * 9 + removed.col];
      
      // Remove 3D marker
      if (cell && cell.marker) {
        channel.scene.remove(cell.marker);
        cell.marker = null;
      }
      
      // Clear cell data
      if (cell) {
        cell.entity = null;
        cell.hasEntity = false;
        cell.entityType = null;
        cell.entityLabel = null;
      }
      
      // Remove from state
      entities.splice(matchIndex, 1);
      appState.gridEntities.set(channel.id, entities);
      
      // Update observer
      const observer = appState.observers.get(channel.id) || createDefaultObserver();
      observer.recentActions.push({
        type: 'remove',
        entity: removed,
        timestamp: Date.now()
      });
      if (observer.recentActions.length > 5) observer.recentActions.shift();
      appState.observers.set(channel.id, observer);
      
      TestSuite.log('üóëÔ∏è', 'REMOVE', `Removed: ${removed.type} "${removed.label}" from (${removed.row},${removed.col})`);
      return true;
    }
    
    function placeEntityOnGrid(channel, entity) {
      if (!channel.gridCells) return;
      const { row, col, type, label } = entity;
      
      const index = row * 9 + col;
      const cell = channel.gridCells[index];
      if (!cell) return;
      
      // Entity colors
      const colors = {
        Goal: 0xffd700,      // Gold
        Obstacle: 0xff5c7c,  // Red
        Entity: 0x56ff9f,    // Green
        Solution: 0x56ff9f,  // Green
        Shift: 0x9370DB,     // Purple
        Location: 0x569fff   // Blue
      };
      
      // Change cell color
      cell.material.color.setHex(colors[type] || 0x56ff9f);
      cell.material.opacity = 0.6;
      cell.hasEntity = true;
      cell.entityType = type;
      cell.entityLabel = label;
      
      // Add 3D marker above cell
      const markerGeometry = new THREE.ConeGeometry(0.5, 2, 8);
      const markerMaterial = new THREE.MeshLambertMaterial({ 
        color: colors[type] || 0x56ff9f,
        emissive: colors[type] || 0x56ff9f,
        emissiveIntensity: 0.3
      });
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      marker.position.set(cell.mesh.position.x, 1.5, cell.mesh.position.z);
      marker.rotation.x = Math.PI;
      channel.scene.add(marker);
      cell.marker = marker;
      
      if (!appState.gridEntities.has(channel.id)) {
        appState.gridEntities.set(channel.id, []);
      }
      appState.gridEntities.get(channel.id).push(entity);
      
      // Update observer (situational awareness)
      const observer = appState.observers.get(channel.id) || createDefaultObserver();
      observer.recentActions.push({
        type: 'add',
        entity: { type, label, row, col },
        timestamp: Date.now()
      });
      if (observer.recentActions.length > 5) observer.recentActions.shift();
      appState.observers.set(channel.id, observer);
      
      // ADD CLICK HANDLER for entity interaction
      if (cell.mesh) {
        cell.mesh.userData.entity = entity;
        cell.mesh.userData.clickable = true;
      }
      if (marker) {
        marker.userData.entity = entity;
        marker.userData.clickable = true;
      }
      
      TestSuite.log('üìç', 'GRID', `Entity placed: ${type} "${label}" at (${row},${col})`);
    }
    
    function checkJunction(channel, row, col, entityType, entityLabel) {
      if (entityType && !channel.atJunction) {
        channel.atJunction = true;
        handleCollision(channel, { type: entityType, label: entityLabel, row, col });
      } else if (!entityType && channel.atJunction) {
        channel.atJunction = false;
      }
    }
    
    // POST-COLLISION ROUTER - Decides what happens after train hits entity
    function handleCollision(channel, entity) {
      TestSuite.log('üí•', 'COLLISION', `Train hit: ${entity.type} "${entity.label}" at (${entity.row},${entity.col})`);
      channel.trainPaused = true;
      
      // Get spatial context around collision point
      const surrounding = getSurroundingCells(channel, entity.row, entity.col);
      const nearbyEntities = surrounding.filter(s => s.entity);
      
      // Narrative framing based on entity type - OUTSIDE the control
      const narrativeFrames = {
        'Obstacle': `‚ö†Ô∏è Orbital intersection with **${entity.label}** - obstruction on ${channel.currentTrack.toUpperCase()} ring`,
        'Entity': `üë§ **${entity.label}** detected in orbit - ${channel.currentTrack.toUpperCase()} ring active`,
        'Solution': `‚ú® **${entity.label}** orbital resonance - solution pattern detected`,
        'Goal': `‚≠ê Approaching **${entity.label}** waypoint`,
        'Location': `üìç Orbital coordinates: **${entity.label}**`
      };
      
      const frame = narrativeFrames[entity.type] || `‚ö†Ô∏è Collision with **${entity.label}**`;
      
      // Brief context message
      addMessage(channel, 'system', frame);
      
      // Show minimal collision menu
      showCollisionMenu(channel, entity, nearbyEntities);
      
      // Store collision in observer for AI context (hidden from user)
      const observer = appState.observers.get(channel.id) || createDefaultObserver();
      observer.recentActions.push({
        type: 'collision',
        entity: entity,
        timestamp: Date.now(),
        nearbyWitnesses: nearbyEntities.map(s => s.entity.label),
        nearbyContext: nearbyEntities.map(s => `${s.direction}: ${s.entity.label}`).join(', ')
      });
      appState.observers.set(channel.id, observer);
    }
    
    function handleJunction(channel, entity) {
      TestSuite.log('üö¶', 'JUNCTION', `Train reached: ${entity.type} "${entity.label}"`);
      channel.trainPaused = true;
      
      // Add junction message with tetrad choices INLINE
      const junctionMsg = {
        role: 'system',
        text: `üö¶ JUNCTION: Reached ${entity.type} "${entity.label}". Choose your path:`,
        hasTetradChoices: true
      };
      channel.messages.push(junctionMsg);
      renderMessages(channel);
      
      if (window.Tone) {
        // Resume AudioContext on user interaction
        Tone.start().then(() => {
          const synth = new Tone.Synth().toDestination();
          synth.triggerAttackRelease('C4', '0.2');
        });
      }
    }
    
    function resumeTrain(channel, trackChoice) {
      TestSuite.log('‚úÖ', 'JUNCTION', `Track chosen: ${trackChoice}`);
      
      // Switch to new track
      channel.currentTrack = trackChoice;
      const newRadius = TRACK_CONFIGS[trackChoice].radius;
      channel.trainCurve = createTrackCurve(newRadius);
      
      // Update info overlay
      if (channel.dom.trainInfo) {
        channel.dom.trainInfo.innerHTML = `Track: <strong>${TRACK_CONFIGS[trackChoice].label}</strong><br>Position: <strong>${Math.round(channel.trainProgress * 100)}%</strong>`;
      }
      
      // Resume movement
      channel.trainPaused = false;
      channel.atJunction = false;
      
      // Add confirmation message
      addMessage(channel, 'system', `‚úÖ Switched to ${TRACK_CONFIGS[trackChoice].label} track.`);
      renderMessages(channel);
    }
    
    TestSuite.log('üîó', 'INTEGRATION', 'Grid-train integration functions loaded');
    
    // ========================================
    // DOM READY: RUN STAGES 5, 8, 9 IN ORDER
    // ========================================
    
    document.addEventListener('DOMContentLoaded', () => {
      TestSuite.log('üåü', 'DOM-READY', '========== DOM READY - RUNNING FINAL STAGES ==========');
      
      // STAGE 5: Create initial channel
      TestSuite.stage = 'STAGE-5-INIT';
      TestSuite.log('üèóÔ∏è', TestSuite.stage, 'Creating initial channel...');
      const initialChannel = initApp();
      
      TestSuite.assert(
        'App initialized',
        initialChannel && appState.currentChannelId,
        `Current channel: ${appState.currentChannelId}`
      );
      TestSuite.stage_summary();
      
      if (!initialChannel) {
        TestSuite.log('‚ùå', 'FATAL', 'Cannot proceed without initial channel!');
        return;
      }
      
      TestSuite.log('‚úÖ', TestSuite.stage, `Channel ready: ${initialChannel.id}`);
      
      // STAGE 8: Render to DOM
      TestSuite.stage = 'STAGE-8-RENDER';
      TestSuite.log('üé®', TestSuite.stage, 'Rendering initial UI...');
      TestSuite.log('üìç', TestSuite.stage, `Rendering channel: ${initialChannel.name}`);
      
      renderChannel(initialChannel);
      TestSuite.log('‚úÖ', TestSuite.stage, 'renderChannel() completed');
      
      // NOW show tetrad controls (DOM exists)
      showTetradControls(initialChannel);
      TestSuite.log('üé≠', TestSuite.stage, 'Tetrad controls displayed');
      
      // Check DOM immediately
      setTimeout(() => {
        const hasColumn = document.querySelector('.channel-column') !== null;
        const hasCanvas = document.querySelector('.train-viewport canvas') !== null;
        const hasMessage = document.querySelector('.message') !== null;
        const hasInput = document.querySelector('.channel-input') !== null;
        
        TestSuite.log('üîç', TestSuite.stage, `DOM Check: column=${hasColumn}, canvas=${hasCanvas}, message=${hasMessage}, input=${hasInput}`);
        
        TestSuite.assert(
          'Channel column rendered',
          hasColumn,
          hasColumn ? 'Channel column in DOM' : '‚ùå NO COLUMN!'
        );
        
        TestSuite.assert(
          'Canvas element exists',
          hasCanvas,
          hasCanvas ? 'Canvas ready for 3D' : '‚ùå NO CANVAS!'
        );
        
        TestSuite.assert(
          'Messages visible',
          hasMessage,
          hasMessage ? `${initialChannel.messages.length} messages` : '‚ùå NO MESSAGES!'
        );
        
        TestSuite.assert(
          'Input field ready',
          hasInput,
          hasInput ? 'User can type' : '‚ùå NO INPUT!'
        );
        
        TestSuite.stage_summary();
        
        // STAGE 9: Initialize 3D
        if (hasCanvas && initialChannel.dom.trainCanvas) {
          TestSuite.stage = 'STAGE-9-3D';
          TestSuite.log('üéÆ', TestSuite.stage, '========== INITIALIZING 3D TRAIN ==========');
          TestSuite.log('üé¨', TestSuite.stage, `Canvas found: ${initialChannel.dom.trainCanvas.width}x${initialChannel.dom.trainCanvas.height}`);
          
          init3DForChannel(initialChannel);
          TestSuite.log('‚úÖ', TestSuite.stage, 'init3DForChannel() completed');
          
          // Verify 3D objects created
          TestSuite.log('üîç', TestSuite.stage, `Scene: ${initialChannel.scene ? 'EXISTS' : 'NULL'}`);
          TestSuite.log('üîç', TestSuite.stage, `Renderer: ${initialChannel.renderer ? 'EXISTS' : 'NULL'}`);
          TestSuite.log('üîç', TestSuite.stage, `Train cars: ${initialChannel.trainCars ? initialChannel.trainCars.length : 0}`);
          
          TestSuite.assert(
            '3D scene created',
            initialChannel.scene !== null,
            initialChannel.scene ? `Scene with ${initialChannel.trainCars.length} cars` : '‚ùå NO SCENE!'
          );
          
          TestSuite.assert(
            '3D renderer created',
            initialChannel.renderer !== null,
            initialChannel.renderer ? 'WebGL active' : '‚ùå NO RENDERER!'
          );
          
          if (initialChannel.scene && initialChannel.renderer) {
            TestSuite.log('‚ñ∂Ô∏è', TestSuite.stage, 'Starting animation loop...');
            animate3D();
            TestSuite.log('‚úÖ', TestSuite.stage, 'Animation loop started!');
            
            // AVATAR CONTROLS: Arrow keys to move, Space to interact
            TestSuite.log('üéÆ', TestSuite.stage, 'Binding avatar controls...');
            document.addEventListener('keydown', (e) => {
              const channel = appState.channels.get(appState.currentChannelId);
              if (!channel || !channel.avatar) return;
              
              const avatar = channel.avatar;
              let newRow = avatar.row;
              let newCol = avatar.col;
              
              switch(e.key) {
                case 'ArrowUp':
                  newRow = Math.max(0, avatar.row - 1);
                  e.preventDefault();
                  break;
                case 'ArrowDown':
                  newRow = Math.min(8, avatar.row + 1);
                  e.preventDefault();
                  break;
                case 'ArrowLeft':
                  newCol = Math.max(0, avatar.col - 1);
                  e.preventDefault();
                  break;
                case 'ArrowRight':
                  newCol = Math.min(8, avatar.col + 1);
                  e.preventDefault();
                  break;
                case ' ':  // Spacebar
                  e.preventDefault();
                  // Check for nearby entities
                  const entities = appState.gridEntities.get(channel.id) || [];
                  // Check for nearby entities in surrounding cells (not just exact position)
              const nearbyEntity = entities.find(ent => 
                Math.abs(ent.row - avatar.row) <= 1 && Math.abs(ent.col - avatar.col) <= 1
              );
              if (nearbyEntity) {
                    addMessage(channel, 'system',
                      `ü§ù **Interacting with ${nearbyEntity.label}**\n\n` +
                      `Type: ${nearbyEntity.type}\n` +
                      `Position: (${nearbyEntity.row}, ${nearbyEntity.col})\n\n` +
                      `(Negotiation system coming soon...)`
                    );
                    renderMessages(channel);
                  } else {
                    addMessage(channel, 'system', '‚ùå No entity here. Move to an entity and press SPACE.');
                    renderMessages(channel);
                  }
                  return;
              }
              
              if (newRow !== avatar.row || newCol !== avatar.col) {
                // Move avatar
                avatar.row = newRow;
                avatar.col = newCol;
                
                const pos = gridRowColToWorld(newRow, newCol);
                avatar.mesh.position.x = pos.x;
                avatar.mesh.position.z = pos.z;
                
                // üéØ UPDATE PSYCHOGRAPH based on position (smooth, non-blocking)
                if (window.schedulePsychographUpdate) {
                  window.schedulePsychographUpdate(channel);
                }
                
                // Check for nearby entities (including adjacent cells)
                const entities = appState.gridEntities.get(channel.id) || [];
                const nearbyEntity = entities.find(ent => 
                  Math.abs(ent.row - newRow) <= 1 && Math.abs(ent.col - newCol) <= 1
                );
                
                if (nearbyEntity) {
                  addMessage(channel, 'system',
                    `üö∂ Moved to (${newRow}, ${newCol})\n\n` +
                    `üìç **${nearbyEntity.label}** is here!\nPress SPACE to interact.`
                  );
                } else {
                  addMessage(channel, 'system', `üö∂ Moved to (${newRow}, ${newCol})`);
                }
                renderMessages(channel);
              }
            });
            TestSuite.log('‚úÖ', TestSuite.stage, 'Avatar controls bound (‚Üë‚Üê‚Üì‚Üí to move, SPACE to interact)');
            
            // DEMO: Place entities on grid to show integration
            setTimeout(() => {
              placeEntityOnGrid(initialChannel, { row: 2, col: 2, type: 'Goal', label: 'Reach the Station' });
              placeEntityOnGrid(initialChannel, { row: 4, col: 4, type: 'Obstacle', label: 'Bridge Out' });
              placeEntityOnGrid(initialChannel, { row: 6, col: 6, type: 'Entity', label: 'Station Master' });
              placeEntityOnGrid(initialChannel, { row: 7, col: 7, type: 'Solution', label: 'Repair Kit' });
              TestSuite.log('üéØ', 'DEMO', 'Demo entities placed on grid - watch train pass through them!');
            }, 1000);
          } else {
            TestSuite.log('‚ùå', TestSuite.stage, 'FAILED: Cannot start animation without scene/renderer');
          }
          
          TestSuite.stage_summary();
        } else {
          TestSuite.log('‚ùå', 'STAGE-9-3D', 'Cannot initialize 3D: No canvas element!');
        }
        
        // BIND GLOBAL CONTROLS (Corner buttons must be bound AFTER DOM ready)
        TestSuite.log('üîó', 'GLOBAL', 'Binding global controls...');
        bindGlobalControls();
        
        // LOAD PSYCHOGRAPH DATASET (inline fallback if external script fails)
        if (!window.schedulePsychographUpdate) {
          TestSuite.log('üìä', 'PSYCHOGRAPH', 'Loading psychograph integration (inline)...');
          
          let PSYCHOGRAPH_DATASET = null;
          let psychographUpdateScheduled = false;
          let lastAvatarPosition = { row: 0, col: 4 };
          
          async function loadPsychographDataset() {
            try {
              const response = await fetch('complete_node_dataset.json');
              PSYCHOGRAPH_DATASET = await response.json();
              TestSuite.log('‚úÖ', 'PSYCHOGRAPH', `Dataset loaded: ${PSYCHOGRAPH_DATASET.known_nodes.length} nodes`);
            } catch (e) {
              TestSuite.log('‚ö†Ô∏è', 'PSYCHOGRAPH', 'Dataset load failed - radar will use manual updates only');
            }
          }
          
          window.schedulePsychographUpdate = function(channel) {
            if (psychographUpdateScheduled) return;
            psychographUpdateScheduled = true;
            requestAnimationFrame(() => {
              if (PSYCHOGRAPH_DATASET && channel.avatar) {
                const { row, col } = channel.avatar;
                if (row === lastAvatarPosition.row && col === lastAvatarPosition.col) return;
                lastAvatarPosition = { row, col };
                
                const currentNode = PSYCHOGRAPH_DATASET.known_nodes.find(n =>
                  n.coordinate[0] === row && n.coordinate[1] === col
                );
                
                if (currentNode && channel.trainingAxisValues) {
                  const axes = ['IDENTITY', 'EXPERIENCE', 'LANGUAGE', 'DOMAIN', 'PURPOSE', 'ORDER'];
                  const axisIndex = axes.indexOf(currentNode.axis.toUpperCase());
                  if (axisIndex >= 0) {
                    channel.trainingAxisValues[axisIndex] = Math.min(0.9, channel.trainingAxisValues[axisIndex] + 0.2);
                    channel.trainingAxisValues.forEach((v, i) => {
                      if (i !== axisIndex) channel.trainingAxisValues[i] = Math.max(0.15, v * 0.95);
                    });
                    if (channel.update3DRadar) channel.update3DRadar();
                  }
                }
              }
              psychographUpdateScheduled = false;
            });
          };
          
          loadPsychographDataset();
        }
        
        // FINAL REPORT
        TestSuite.log('üéâ', 'COMPLETE', `========== INTEGRATION COMPLETE: ${TestSuite.passed} TESTS PASSED ==========`);
        TestSuite.report();
      }, 50);
    });
    
    // ========================================
    // STAGE 6: DOM RENDERING
    // ========================================
    
    TestSuite.stage = 'STAGE-6-DOM';
    TestSuite.log('üé®', TestSuite.stage, 'Building DOM rendering system...');
    
    function createChannelDOM(channel) {
      const column = document.createElement('div');
      column.className = 'channel-column';
      column.dataset.channelId = channel.id;
      
      // Header with buttons
      const header = document.createElement('div');
      header.className = 'channel-head';
      
      // Add channel title with polarity and axis labels
      const titleDiv = document.createElement('div');
      titleDiv.style.cssText = `
        padding: 8px 12px;
        border-bottom: 1px solid var(--border);
        background: var(--panel-dark);
      `;
      
      let titleHTML = `<div style="font-size: 14px; font-weight: 700; letter-spacing: 0.05em;">${channel.name}</div>`;
      
      // Add polarity-specific axis labels (CLICKABLE)
      if (channel.sceneType === 'POLARITY_INNER') {
        const axisLabels = TRAINING_GROUND.AXES.map((axis, idx) => {
          const label = TRAINING_GROUND.INNER_LABELS[axis];
          return `<span class="axis-link" data-axis="${axis}" data-label="${label}" data-channel="${channel.id}" style="cursor: pointer; text-decoration: underline; opacity: 0.8; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'" onclick="focusOnAxis('${channel.id}', '${axis}', '${label}')">${label}</span>`;
        }).join(' ¬∑ ');
        titleHTML += `
          <div style="font-size: 10px; color: #ff5c7c; margin-top: 4px;">
            ‚ö° INNER: ${axisLabels}
          </div>`;
      } else if (channel.sceneType === 'POLARITY_OUTER') {
        const axisLabels = TRAINING_GROUND.AXES.map((axis, idx) => {
          const label = TRAINING_GROUND.OUTER_LABELS[axis];
          return `<span class="axis-link" data-axis="${axis}" data-label="${label}" data-channel="${channel.id}" style="cursor: pointer; text-decoration: underline; opacity: 0.8; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'" onclick="focusOnAxis('${channel.id}', '${axis}', '${label}')">${label}</span>`;
        }).join(' ¬∑ ');
        titleHTML += `
          <div style="font-size: 10px; color: #569fff; margin-top: 4px;">
            üåê OUTER: ${axisLabels}
          </div>`;
      } else if (channel.sceneType === 'META_OBSERVER') {
        titleHTML += `
          <div style="font-size: 10px; color: #c78fff; margin-top: 4px;">
            üëÅÔ∏è OBSERVER: Watches Both Polarities
          </div>`;
      }
      
      titleDiv.innerHTML = titleHTML;
      header.appendChild(titleDiv);
      
      const actions = document.createElement('div');
      actions.className = 'channel-actions';
      
      // Grid toggle button (bind event AFTER trainViewport created)
      const gridToggleBtn = document.createElement('button');
      gridToggleBtn.className = 'channel-btn';
      gridToggleBtn.title = 'Toggle 3D viewport';
      gridToggleBtn.textContent = '‚ñ≤';
      // Event handler added later after trainViewport exists
      
      // Reset button
      const resetBtn = document.createElement('button');
      resetBtn.className = 'channel-btn';
      resetBtn.title = 'Reset channel';
      resetBtn.textContent = '‚Ü∫';
      resetBtn.addEventListener('click', () => {
        if (confirm('Reset this channel? All messages and entities will be cleared.')) {
          channel.messages = [];
          appState.gridEntities.set(channel.id, []);
          // Clear 3D markers
          if (channel.gridCells) {
            channel.gridCells.forEach(cell => {
              if (cell.marker) channel.scene.remove(cell.marker);
            });
          }
          addMessage(channel, 'system', '‚úÖ Channel reset.');
          renderMessages(channel);
        }
      });
      
      // Camera reset button
      const cameraResetBtn = document.createElement('button');
      cameraResetBtn.className = 'channel-btn';
      cameraResetBtn.title = 'Reset camera view';
      cameraResetBtn.textContent = '‚óâ';
      cameraResetBtn.addEventListener('click', () => {
        if (channel.camera) {
          channel.camera.position.set(0, 15, 15);
          channel.camera.lookAt(0, 0, 0);
          if (channel.controls) {
            channel.controls.target.set(0, 0, 0);
            channel.controls.update();
          }
          channel.cameraFollowMode = false;
          addMessage(channel, 'system', 'üé• Camera reset to overview');
          renderMessages(channel);
          TestSuite.log('üé•', 'CAMERA', 'Camera reset to overview');
        }
      });
      
      // Fullscreen button
      const fullscreenBtn = document.createElement('button');
      fullscreenBtn.className = 'channel-btn';
      fullscreenBtn.title = 'Toggle fullscreen';
      fullscreenBtn.textContent = '‚õ∂';
      fullscreenBtn.addEventListener('click', () => {
        if (!document.fullscreenElement) {
          document.body.requestFullscreen().catch(err => {
            console.warn('Fullscreen failed:', err);
          });
          fullscreenBtn.classList.add('fullscreen-mode');
        } else {
          document.exitFullscreen();
          fullscreenBtn.classList.remove('fullscreen-mode');
        }
      });
      
      // Collapse column button with expand tab
      const collapseBtn = document.createElement('button');
      collapseBtn.className = 'channel-btn';
      collapseBtn.title = 'Collapse column';
      collapseBtn.textContent = '‚Äπ';
      
      // Create expand tab
      const expandTab = document.createElement('div');
      expandTab.className = 'channel-expand-tab';
      // Display controlled by CSS: .channel-column.collapsed .channel-expand-tab { display: flex; }
      
      const expandDot = document.createElement('div');
      expandDot.style.cssText = 'width: 10px; height: 10px; border-radius: 50%; background: var(--accent); border: 1px solid var(--border);';
      
      // Add channel label to expand tab
      const expandLabel = document.createElement('div');
      expandLabel.style.cssText = `
        font-size: 8px;
        color: var(--text-muted);
        font-weight: 700;
        letter-spacing: 0.05em;
        writing-mode: vertical-rl;
        text-orientation: mixed;
      `;
      expandLabel.textContent = channel.name.slice(0, 10);
      
      const expandArrow = document.createElement('div');
      expandArrow.style.cssText = 'font-size: 16px; color: var(--text-muted);';
      expandArrow.textContent = '‚Ä∫';
      
      expandTab.appendChild(expandDot);
      expandTab.appendChild(expandLabel);
      expandTab.appendChild(expandArrow);
      
      expandTab.addEventListener('click', (e) => {
        e.stopPropagation();
        column.classList.remove('collapsed');
        channel.collapsed = false;
        collapseBtn.textContent = '‚Äπ';
        TestSuite.log('‚ñ∂Ô∏è', 'UI', `Channel ${channel.name} expanded via tab`);
      });
      
      column.appendChild(expandTab);
      
      collapseBtn.addEventListener('click', () => {
        column.classList.toggle('collapsed');
        channel.collapsed = column.classList.contains('collapsed');
        collapseBtn.textContent = channel.collapsed ? '‚Ä∫' : '‚Äπ';
        TestSuite.log('üîÑ', 'UI', `Channel ${channel.name} ${channel.collapsed ? 'collapsed' : 'expanded'}`);
      });
      
      // Hover effects for expand tab
      expandTab.addEventListener('mouseenter', () => {
        expandTab.style.background = 'var(--accent)';
      });
      
      expandTab.addEventListener('mouseleave', () => {
        expandTab.style.background = 'var(--panel)';
      });
      
      if (channel.collapsed) {
        column.classList.add('collapsed');
        collapseBtn.textContent = '‚Ä∫';
      }
      
      actions.appendChild(gridToggleBtn);
      actions.appendChild(resetBtn);
      actions.appendChild(cameraResetBtn);
      actions.appendChild(fullscreenBtn);
      actions.appendChild(collapseBtn);
      
      header.appendChild(actions);
      
      // Camera modes (empty for now, kept for reference)
      const cameraModes = null;
      
      // Train viewport
      const trainViewport = document.createElement('div');
      trainViewport.className = 'train-viewport';
      const trainCanvas = document.createElement('canvas');
      const vpWidth = 400;
      const vpHeight = 450;
      trainCanvas.width = vpWidth;
      trainCanvas.height = vpHeight;
      trainViewport.appendChild(trainCanvas);
      
      // Hexagon now drawn on grid plane, not as overlay
      channel.hexagonCanvas = null; // Removed HUD overlay
      
      const trainInfo = document.createElement('div');
      trainInfo.className = 'train-info-overlay';
      trainInfo.innerHTML = `Track: <strong>${TRACK_CONFIGS[channel.currentTrack].label}</strong><br>Position: <strong>0%</strong>`;
      trainViewport.appendChild(trainInfo);
      
      // NOW bind grid toggle button (trainViewport exists)
      gridToggleBtn.addEventListener('click', () => {
        trainViewport.classList.toggle('collapsed');
        gridToggleBtn.textContent = trainViewport.classList.contains('collapsed') ? '‚ñº' : '‚ñ≤';
        TestSuite.log('üîΩ', 'UI', `Viewport ${trainViewport.classList.contains('collapsed') ? 'collapsed' : 'expanded'}`);
      });
      
      // Resize bar
      const resizeBar = document.createElement('div');
      resizeBar.className = 'resize-bar';
      
      let isResizing = false;
      let startY = 0;
      let startHeight = 450;
      
      resizeBar.addEventListener('mousedown', (e) => {
        isResizing = true;
        startY = e.clientY;
        startHeight = trainViewport.offsetHeight;
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const deltaY = e.clientY - startY;
        const newHeight = Math.max(200, startHeight + deltaY); // Removed 800px limit
        trainViewport.style.height = newHeight + 'px';
        
        // Dynamic grid scaling when viewport exceeds 800px
        if (newHeight > 800 && channel.gridCells && channel.gridCells.length > 0) {
          const scale = newHeight / 450; // Base height is 450px
          channel.gridCells.forEach(cell => {
            if (cell && cell.scale) {
              cell.scale.set(scale, 1, scale);
            }
          });
          // Adjust camera for larger view
          if (channel.camera) {
            const camScale = Math.min(2.0, scale);
            channel.camera.position.y = 15 * camScale;
            channel.camera.position.z = 15 * camScale;
          }
        }
      });
      
      document.addEventListener('mouseup', () => {
        isResizing = false;
      });
      
      // Touch support
      resizeBar.addEventListener('touchstart', (e) => {
        isResizing = true;
        startY = e.touches[0].clientY;
        startHeight = trainViewport.offsetHeight;
      });
      
      document.addEventListener('touchmove', (e) => {
        if (!isResizing) return;
        const deltaY = e.touches[0].clientY - startY;
        const newHeight = Math.max(200, startHeight + deltaY); // Removed 800px limit
        trainViewport.style.height = newHeight + 'px';
        
        // Dynamic grid scaling when viewport exceeds 800px
        if (newHeight > 800 && channel.gridCells && channel.gridCells.length > 0) {
          const scale = newHeight / 450; // Base height is 450px
          channel.gridCells.forEach(cell => {
            if (cell && cell.scale) {
              cell.scale.set(scale, 1, scale);
            }
          });
          // Adjust camera for larger view
          if (channel.camera) {
            const camScale = Math.min(2.0, scale);
            channel.camera.position.y = 15 * camScale;
            channel.camera.position.z = 15 * camScale;
          }
        }
      });
      
      document.addEventListener('touchend', () => {
        isResizing = false;
      });
      
      // Chat section with message dots
      const chatSection = document.createElement('div');
      chatSection.className = 'chat-section';
      
      const chatStream = document.createElement('div');
      chatStream.className = 'chat-stream';
      
      const messageDotRail = document.createElement('div');
      messageDotRail.className = 'message-dot-rail';
      
      const messageList = document.createElement('div');
      messageList.className = 'message-list';
      
      chatStream.appendChild(messageDotRail);
      chatStream.appendChild(messageList);
      chatSection.appendChild(chatStream);
      
      // Footer
      const footer = document.createElement('div');
      footer.className = 'channel-footer';
      
      const inputRow = document.createElement('div');
      inputRow.className = 'input-row';
      
      const input = document.createElement('textarea');
      input.className = 'channel-input';
      input.placeholder = 'Type your message...';
      input.rows = 2;
      
      const sendBtn = document.createElement('button');
      sendBtn.className = 'send-btn';
      sendBtn.textContent = 'SEND';
      
      inputRow.appendChild(input);
      inputRow.appendChild(sendBtn);
      
      footer.appendChild(inputRow);
      
      // Footer separator - visual divider between chat and input
      const footerSeparator = document.createElement('div');
      footerSeparator.className = 'footer-separator';
      
      // Assemble
      column.appendChild(header);
      column.appendChild(trainViewport);
      column.appendChild(resizeBar);
      column.appendChild(chatSection);
      column.appendChild(footerSeparator);
      column.appendChild(footer);
      
      // Click to set as current channel
      column.addEventListener('click', (e) => {
        if (!e.target.closest('.channel-input, .send-btn, .channel-btn')) {
          appState.currentChannelId = channel.id;
        }
      });
      
      // Store DOM references
      channel.dom = {
        channelColumn: column,
        column,
        header,
        trainViewport,
        trainCanvas,
        trainInfo,
        resizeBar,
        chatSection,
        messageDotRail,
        messageList,
        input,
        sendBtn,
        gridToggleBtn,
        resetBtn,
        collapseBtn,
        cameraModes
      };
      
      TestSuite.log('üèóÔ∏è', TestSuite.stage, `DOM created for channel ${channel.name}`);
      return column;
    }
    
    function renderMessages(channel) {
      // Safety check: DOM must exist before rendering
      if (!channel.dom || !channel.dom.messageList) {
        console.warn('renderMessages: channel.dom not initialized for', channel.name);
        return;
      }
      
      const messageList = channel.dom.messageList;
      const messageDotRail = channel.dom.messageDotRail;
      
      messageList.innerHTML = '';
      if (messageDotRail) messageDotRail.innerHTML = '';
      
      // AUTO-COLLAPSE: Only show last 5 messages fully, collapse older ones
      const totalMessages = channel.messages.filter(m => !m.hidden).length;
      const startCollapseIdx = Math.max(0, totalMessages - 5);
      
      let visibleIdx = 0;
      channel.messages.forEach((msg, idx) => {
        // Skip hidden messages (AI control prompts)
        if (msg.hidden) return;
        
        const isCollapsed = visibleIdx < startCollapseIdx;
        visibleIdx++;
        
        // Create message dot
        if (messageDotRail) {
          const dot = document.createElement('button');
          dot.className = `message-dot ${msg.role}`;
          dot.dataset.messageId = msg.id;
          dot.dataset.index = idx;
          dot.title = `${msg.role}: ${msg.text.substring(0, 50)}...`;
          dot.addEventListener('click', () => {
            // Scroll to message
            const msgElement = messageList.children[idx];
            if (msgElement) {
              msgElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
              // Highlight
              document.querySelectorAll('.message-dot').forEach(d => d.classList.remove('active'));
              dot.classList.add('active');
            }
          });
          messageDotRail.appendChild(dot);
        }
        
        // Create message
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${msg.role} ${isCollapsed ? 'collapsed' : ''}`;
        
        if (isCollapsed) {
          // Collapsed view - single line with expand button
          messageDiv.style.cssText = 'opacity: 0.5; cursor: pointer; max-height: 24px; overflow: hidden; margin: 2px 0;';
          messageDiv.title = 'Click to expand';
          messageDiv.onclick = () => {
            messageDiv.classList.remove('collapsed');
            messageDiv.style.cssText = '';
            messageDiv.onclick = null;
          };
          
          const preview = document.createElement('div');
          preview.style.cssText = 'font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
          preview.textContent = `${msg.role}: ${msg.text.substring(0, 60)}...`;
          messageDiv.appendChild(preview);
        } else {
          // Full message view
          const body = document.createElement('div');
          body.className = 'message-body';
          if (msg.isHTML) {
            body.innerHTML = msg.text.replace(/\\n/g, '<br>');
          } else {
            body.textContent = msg.text;
          }
          messageDiv.appendChild(body);
        }
        
        // Add tetrad choice buttons if this is a junction message
        if (msg.hasTetradChoices) {
          const choicesDiv = document.createElement('div');
          choicesDiv.className = 'tetrad-choices-inline';
          choicesDiv.style.cssText = 'display:flex; gap:8px; margin-top:12px; flex-wrap:wrap;';
          
          ['enhance', 'reverse', 'retrieve', 'obsolesce'].forEach(track => {
            const btn = document.createElement('button');
            btn.className = `tetrad-chip ${track}`;
            btn.textContent = track === 'enhance' ? '‚Üó ENHANCE' :
                             track === 'reverse' ? '‚Üô REVERSE' :
                             track === 'retrieve' ? '‚Üë RETRIEVE' : '‚Üì OBSOLESCE';
            btn.style.cssText = 'flex:1; min-width:120px;';
            btn.addEventListener('click', () => {
              resumeTrain(channel, track);
              // Remove choices after selection
              choicesDiv.remove();
            });
            choicesDiv.appendChild(btn);
          });
          
          messageDiv.appendChild(choicesDiv);
        }
        
        messageList.appendChild(messageDiv);
      });
      
      messageList.scrollTop = messageList.scrollHeight;
      TestSuite.log('üí¨', TestSuite.stage, `Rendered ${channel.messages.length} messages`);
    }
    
    async function sendMessageWithLEGOS(channel, userText) {
      // SIMPLE CHAT COMMANDS (no API needed)
      const lowerText = userText.toLowerCase().trim();
      
      // ADDFIRE command - Quick entity placement
      if (lowerText === 'addfire' || lowerText === 'add fire') {
        const emptyCell = findRandomEmptyCell(channel);
        if (!emptyCell) {
          addMessage(channel, 'system', '‚ö†Ô∏è Grid full! No space for fire.');
          renderMessages(channel);
          return;
        }
        
        const fire = createGridEntity(channel, emptyCell.row, emptyCell.col, 'Fire', 'üî•', 0xff4500);
        const entities = appState.gridEntities.get(channel.id) || [];
        entities.push(fire);
        appState.gridEntities.set(channel.id, entities);
        
        addMessage(channel, 'system', `üî• Fire created at (${emptyCell.row}, ${emptyCell.col})!`);
        renderMessages(channel);
        return;
      }
      
      // SHOW GRID command
      if (lowerText === 'show grid' || lowerText === 'list entities' || lowerText === 'what\'s on grid') {
        const entities = appState.gridEntities.get(channel.id) || [];
        if (entities.length === 0) {
          addMessage(channel, 'system', 'üìã Grid is empty. No entities placed yet.');
        } else {
          const list = entities.map((e, i) => `${i+1}. ${e.type} "${e.label}" at (${e.row},${e.col})`).join('\n');
          addMessage(channel, 'system', `üìã Grid Contents (${entities.length} entities):\n${list}`);
        }
        renderMessages(channel);
        return;
      }
      
      // NODE VIEWER COMMANDS
      if (lowerText === 'list nodes' || lowerText === 'show nodes' || lowerText === 'all nodes') {
        if (window.listNodes) window.listNodes(null, channel);
        else addMessage(channel, 'system', '‚ö†Ô∏è Node viewer not loaded yet');
        renderMessages(channel);
        return;
      }
      
      if (lowerText === 'list inner' || lowerText === 'inner nodes') {
        if (window.listNodes) window.listNodes('inner', channel);
        else addMessage(channel, 'system', '‚ö†Ô∏è Node viewer not loaded yet');
        renderMessages(channel);
        return;
      }
      
      if (lowerText === 'list outer' || lowerText === 'outer nodes') {
        if (window.listNodes) window.listNodes('outer', channel);
        else addMessage(channel, 'system', '‚ö†Ô∏è Node viewer not loaded yet');
        renderMessages(channel);
        return;
      }
      
      if (lowerText === 'list synthetic' || lowerText === 'synthetic nodes') {
        if (window.listNodes) window.listNodes('synthetic', channel);
        else addMessage(channel, 'system', '‚ö†Ô∏è Node viewer not loaded yet');
        renderMessages(channel);
        return;
      }
      
      if (lowerText.startsWith('show node ')) {
        const nodeId = lowerText.replace('show node ', '').trim();
        if (window.showNode) window.showNode(nodeId, channel);
        else addMessage(channel, 'system', '‚ö†Ô∏è Node viewer not loaded yet');
        renderMessages(channel);
        return;
      }
      
      if (lowerText.startsWith('focus ')) {
        const axisName = lowerText.replace('focus ', '').trim();
        if (window.focusAxis) window.focusAxis(axisName, channel);
        else addMessage(channel, 'system', '‚ö†Ô∏è Node viewer not loaded yet');
        renderMessages(channel);
        return;
      }
      
      // AXIS @MENTION HANDLING - Chat with specific axes
      const axisLabels = [...Object.values(TRAINING_GROUND.INNER_LABELS), ...Object.values(TRAINING_GROUND.OUTER_LABELS)];
      const mentionedAxis = axisLabels.find(label => 
        userText.toLowerCase().includes(`@${label.toLowerCase()}`)
      );
      
      if (mentionedAxis) {
        // Find which axis this is
        const axisName = Object.keys(TRAINING_GROUND.INNER_LABELS).find(k => 
          TRAINING_GROUND.INNER_LABELS[k] === mentionedAxis
        ) || Object.keys(TRAINING_GROUND.OUTER_LABELS).find(k => 
          TRAINING_GROUND.OUTER_LABELS[k] === mentionedAxis
        );
        
        const isInner = Object.values(TRAINING_GROUND.INNER_LABELS).includes(mentionedAxis);
        const polarity = isInner ? 'INNER' : 'OUTER';
        const emoji = isInner ? 'üî¥' : 'üîµ';
        
        // Add context about the axis to the AI prompt
        const axisContext = `\n\n[AXIS CONTEXT: User is chatting with the ${mentionedAxis} axis (${axisName}, ${polarity} polarity). Respond from the perspective of this axis dimension. Use "I" to speak as ${mentionedAxis}.]`;
        
        addMessage(channel, 'user', userText);
        addMessage(channel, 'system', `${emoji} Connecting to **${mentionedAxis}** axis...`);
        renderMessages(channel);
        
        // Continue to API with enriched context
        userText = userText + axisContext;
      }
      
      // TRAINING NODE PLACEMENT - @shed, @integrate, @ground
      if (lowerText.startsWith('@shed') || lowerText.startsWith('@integrate') || lowerText.startsWith('@ground')) {
        const stageName = lowerText.split(' ')[0].substring(1).toUpperCase();
        const rest = userText.split(' ').slice(1).join(' ');
        
        // üîí UNLOCK CHECK: Operation must be unlocked first
        if (channel.unlockedOperations && !channel.unlockedOperations[stageName.toLowerCase()]) {
          const unlockHints = {
            shed: 'üîí SHED is locked. Clear 3+ entities from the scene to unlock.',
            integrate: 'üîí INTEGRATE is locked. Merge 2+ entities together to unlock.',
            ground: 'üîí GROUND is locked. Stack 2+ entities to create structure and unlock.'
          };
          addMessage(channel, 'system', 
            `${unlockHints[stageName.toLowerCase()]}\n\n` +
            `üí¨ Try chatting with entities to learn what can be cleared, merged, or stacked.\n\n` +
            `Your progress:\n` +
            `- Cleared: ${channel.progressionStats.entitiesCleared}/3\n` +
            `- Merged: ${channel.progressionStats.entitiesMerged}/2\n` +
            `- Stacked: ${channel.progressionStats.entitiesStacked}/2`
          );
          renderMessages(channel);
          return;
        }
        
        // Parse axis and pair from remaining text
        let axisName = null;
        let pairName = 'INNER'; // Default
        
        TRAINING_GROUND.AXES.forEach(axis => {
          if (rest.toLowerCase().includes(axis.toLowerCase())) {
            axisName = axis;
          }
        });
        
        if (rest.toLowerCase().includes('outer')) pairName = 'OUTER';
        
        if (!axisName) {
          addMessage(channel, 'system', `‚ùå Specify an axis: ${TRAINING_GROUND.AXES.join(', ')}\n\nExample: @${stageName.toLowerCase()} IDENTITY inner`);
          renderMessages(channel);
          return;
        }
        
        // SCENE-AWARE ROUTING: Check if scene allows this polarity
        if (channel.allowedPolarity && channel.allowedPolarity !== 'BOTH' && channel.allowedPolarity !== pairName) {
          addMessage(channel, 'system', 
            `‚ö†Ô∏è **SCENE CONSTRAINT**: This is the ${channel.role} scene.\n\n` +
            `You can only place **${channel.allowedPolarity}** nodes here.\n\n` +
            `You tried to place **${pairName}**.\n\n` +
            `Switch to the ${pairName} scene to perform this operation, or use a shared scene.`
          );
          renderMessages(channel);
          return;
        }
        
        const nodeData = TRAINING_GROUND.FLOW[stageName][axisName][pairName];
        
        // Find empty cell
        const entities = appState.gridEntities.get(channel.id) || [];
        const occupiedCells = new Set(entities.map(e => `${e.row},${e.col}`));
        let emptyCell = null;
        
        for (let row = 0; row < 9 && !emptyCell; row++) {
          for (let col = 0; col < 9 && !emptyCell; col++) {
            if (!occupiedCells.has(`${row},${col}`)) {
              emptyCell = { row, col };
            }
          }
        }
        
        if (!emptyCell) {
          addMessage(channel, 'system', '‚ùå Grid is full! Clear some entities first.');
          renderMessages(channel);
          return;
        }
        
        // Place node on grid
        const entity = {
          row: emptyCell.row,
          col: emptyCell.col,
          type: stageName,
          label: `${axisName}-${pairName}`,
          nodeData: nodeData
        };
        
        placeEntityOnGrid(channel, entity);
        entities.push(entity);
        appState.gridEntities.set(channel.id, entities);
        
        // Update axis value for radar
        if (!channel.trainingAxisValues) {
          channel.trainingAxisValues = TRAINING_GROUND.AXES.map(() => 0.3);
        }
        const axisIndex = TRAINING_GROUND.AXES.indexOf(axisName);
        channel.trainingAxisValues[axisIndex] = Math.min(1.0, channel.trainingAxisValues[axisIndex] + 0.15);
        
        // UPDATE 3D RADAR VISUALIZATION
        if (channel.update3DRadar) {
          channel.update3DRadar();
          console.log('üìä Radar updated for axis:', axisName, 'new value:', channel.trainingAxisValues[axisIndex]);
          
          // TRIGGER OBSERVER PULSE: This placement affects the observer
          if (channel.radarLines) {
            channel.observerPulseActive = true;
            channel.observerPulseTime = Date.now();
            console.log('‚ú® Observer pulse triggered by', channel.role || channel.name, 'placement');
          }
        }
        
        // Update scene-specific context window
        if (channel.contextWindow) {
          channel.contextWindow.placements.push({
            stage: stageName,
            axis: axisName,
            pair: pairName,
            text: nodeData.text,
            target: nodeData.target,
            timestamp: Date.now()
          });
          channel.contextWindow.axisValues[axisName] = channel.trainingAxisValues[axisIndex];
        }
        
        // Update observer state (tracks INNER vs OUTER separately)
        if (appState.observerState) {
          const obs = appState.observerState;
          
          // Track by polarity
          if (pairName === 'INNER') {
            obs.innerBalance[axisName] = channel.trainingAxisValues[axisIndex];
          } else {
            obs.outerBalance[axisName] = channel.trainingAxisValues[axisIndex];
          }
          
          // Track stage counts
          obs.stageCounts[stageName]++;
          
          // Track placement history
          obs.placements.push({
            stage: stageName,
            axis: axisName,
            pair: pairName,
            timestamp: Date.now(),
            channel: channel.role || channel.name,
            sceneType: channel.sceneType || 'unknown'
          });
          
          // Update OBSERVER scene's context window (it sees everything)
          if (appState.sceneRegistry && appState.sceneRegistry.OBSERVER && appState.sceneRegistry.OBSERVER.contextWindow) {
            const obsContext = appState.sceneRegistry.OBSERVER.contextWindow;
            if (pairName === 'INNER') {
              obsContext.innerPlacements.push({ stage: stageName, axis: axisName, operation: nodeData.text });
              obsContext.innerAxisValues[axisName] = channel.trainingAxisValues[axisIndex];
            } else {
              obsContext.outerPlacements.push({ stage: stageName, axis: axisName, operation: nodeData.text });
              obsContext.outerAxisValues[axisName] = channel.trainingAxisValues[axisIndex];
            }
          }
          
          // Check for imbalances
          const innerTotal = Object.values(obs.innerBalance).reduce((a, b) => a + b, 0);
          const outerTotal = Object.values(obs.outerBalance).reduce((a, b) => a + b, 0);
          const diff = Math.abs(innerTotal - outerTotal);
          
          if (diff > 1.5 && obs.placements.length > 3) {
            const dominant = innerTotal > outerTotal ? 'INNER' : 'OUTER';
            obs.imbalances.push({
              type: 'polarity_imbalance',
              dominant,
              diff,
              timestamp: Date.now()
            });
            
            console.log(`\n‚ö†Ô∏è OBSERVER: Imbalance detected (#${obs.imbalances.length})`);
            console.log(`  Dominant polarity: ${dominant}`);
            console.log(`  Difference: ${diff.toFixed(1)} units`);
            console.log(`  INNER total: ${innerTotal.toFixed(1)}`);
            console.log(`  OUTER total: ${outerTotal.toFixed(1)}`);
            
            // Observer speaks about imbalance
            if (window.observerChannel && obs.imbalances.length % 3 === 0) {
              console.log(`  üó£Ô∏è Observer scene alerted (every 3rd imbalance)`);
              addMessage(window.observerChannel, 'system', 
                `‚öñÔ∏è **IMBALANCE DETECTED**\n\n${dominant} polarity dominant by ${diff.toFixed(1)} units.\n\n` +
                `INNER total: ${innerTotal.toFixed(1)}\nOUTER total: ${outerTotal.toFixed(1)}\n\n` +
                `This asymmetry reveals bias in apparatus organization. ${dominant === 'INNER' ? 
                  'Focus on subjective/instinctual operations. External structure neglected.' : 
                  'Focus on objective/structural operations. Internal experience neglected.'}`
              );
              if (window.observerChannel.dom) renderMessages(window.observerChannel);
            }
          }
        }
        
        // Update 3D radar geometry
        if (channel.update3DRadar) {
          channel.update3DRadar();
        }
        
        // Generate apparatus-conscious commentary
        let commentary = '';
        if (stageName === 'SHED') {
          commentary = `\n\nüî¥ **APPARATUS ACKNOWLEDGMENT**: You are using SHED to organize your grid. SHED itself is an apparatus operation. Every placement confirms the structure.\n\n*"${nodeData.text}"* assumes there IS excess to shed. But what if the excess is apparatus-generated? You're shedding using the tool that created the clutter.`;
        } else if (stageName === 'INTEGRATE') {
          commentary = `\n\nüîµ **SYNTHESIS RECOGNITION**: INTEGRATE connects discrete units into patterns. But these "discrete units" were created by SHED. You're integrating what was artificially separated.\n\n*"${nodeData.text}"* - The coherence you seek was broken by the apparatus that now offers to restore it.`;
        } else if (stageName === 'GROUND') {
          commentary = `\n\nüü¢ **GROUNDLESSNESS ALERT**: You are attempting to GROUND (stabilize, fix, institutionalize). But ground is itself groundless‚Äîit requires prior ground.\n\n*"${nodeData.text}"* appears to offer stability. But this stability is temporary apparatus. The training ground has no exit.`;
        }
        
        addMessage(channel, 'system', `‚úÖ Placed **${nodeData.pair}** (${stageName} ‚Ä¢ ${axisName} ‚Ä¢ ${pairName}) at (${emptyCell.row},${emptyCell.col})\n\nüìç Operation: ${nodeData.text}\nüéØ Target: ${nodeData.target}\n\nüìä ${axisName} axis: ${(channel.trainingAxisValues[axisIndex] * 100).toFixed(0)}% | Radar polygon updated${commentary}`);
        renderMessages(channel);
        return;
      }
      
      // LOAD DATASET COMMAND
      if (lowerText === 'load dataset' || lowerText === '/dataset') {
        try {
          const response = await fetch('/Users/gaia/FUNC-SUB/complete_node_dataset.json');
          const dataset = await response.json();
          addMessage(channel, 'system', 
            `‚úÖ Dataset loaded!\n\n` +
            `Nodes: ${Object.keys(dataset).length}\n` +
            `Use: @shed IDENTITY inner, @integrate LANGUAGE outer, etc.`
          );
          // Store in channel for reference
          channel.dataset = dataset;
        } catch (e) {
          addMessage(channel, 'system', `‚ùå Failed to load dataset: ${e.message}`);
        }
        renderMessages(channel);
        return;
      }
      
      // SHOW OBSERVER STATE
      if (lowerText === 'show observer' || lowerText === '/observer' || lowerText === 'observer') {
        if (!appState.observerState) {
          addMessage(channel, 'system', '‚ö†Ô∏è Observer state not initialized. Use centaur mode with three channels.');
          renderMessages(channel);
          return;
        }
        
        const obs = appState.observerState;
        const innerTotal = Object.values(obs.innerBalance).reduce((a, b) => a + b, 0);
        const outerTotal = Object.values(obs.outerBalance).reduce((a, b) => a + b, 0);
        const imbalance = Math.abs(innerTotal - outerTotal);
        
        const innerBreakdown = TRAINING_GROUND.AXES.map(axis => 
          `  ${axis}: ${(obs.innerBalance[axis] * 100).toFixed(0)}%`
        ).join('\n');
        
        const outerBreakdown = TRAINING_GROUND.AXES.map(axis =>
          `  ${axis}: ${(obs.outerBalance[axis] * 100).toFixed(0)}%`
        ).join('\n');
        
        const stageDist = `SHED: ${obs.stageCounts.SHED} | INTEGRATE: ${obs.stageCounts.INTEGRATE} | GROUND: ${obs.stageCounts.GROUND}`;
        
        const recentPlacements = obs.placements.slice(-5).map(p => 
          `  ‚Ä¢ ${p.stage} ‚Üí ${p.axis} (${p.pair}) via ${p.channel}`
        ).join('\n');
        
        const warning = imbalance > 1.0 ? '‚ö†Ô∏è SIGNIFICANT IMBALANCE!' : imbalance > 0.5 ? '‚öñÔ∏è Minor imbalance detected' : '‚úÖ Relatively balanced';
        
        addMessage(channel, 'system', `
üìä **OBSERVER STATE** ${warning}

**INNER Balance** (Total: ${(innerTotal * 100).toFixed(0)}%):
${innerBreakdown}

**OUTER Balance** (Total: ${(outerTotal * 100).toFixed(0)}%):
${outerBreakdown}

**Imbalance Score:** ${imbalance.toFixed(2)}

**Stage Distribution:**
${stageDist}

**Recent Placements:**
${recentPlacements || '  (none yet)'}
        `);
        
        // Update observer's radar to show COMBINED state
        if (channel.role === 'OBSERVER' && channel.update3DRadar) {
          // Average INNER and OUTER for observer visualization
          channel.trainingAxisValues = TRAINING_GROUND.AXES.map((axis, i) => 
            (obs.innerBalance[axis] + obs.outerBalance[axis]) / 2
          );
          channel.update3DRadar();
          
          // TRIGGER OBSERVER PULSE: Make radar rays glow brighter temporarily
          if (channel.radarLines) {
            channel.observerPulseActive = true;
            channel.observerPulseTime = Date.now();
            console.log('üìä Observer radar updated with combined INNER/OUTER state + PULSE ACTIVATED');
          }
        }
        
        renderMessages(channel);
        return;
      }
      
      // OBSERVER STATUS COMMAND
      if (lowerText === 'show observer' || lowerText === '/observer' || lowerText === 'observer status') {
        if (!appState.observerState) {
          addMessage(channel, 'system', '‚ö†Ô∏è Observer state not initialized. Use centaur mode with three channels.');
          renderMessages(channel);
          return;
        }
        
        const obs = appState.observerState;
        const innerTotal = Object.values(obs.innerBalance).reduce((a, b) => a + b, 0);
        const outerTotal = Object.values(obs.outerBalance).reduce((a, b) => a + b, 0);
        const imbalance = Math.abs(innerTotal - outerTotal);
        
        const innerBreakdown = TRAINING_GROUND.AXES.map(axis => 
          `  ${axis}: ${(obs.innerBalance[axis] * 100).toFixed(0)}%`
        ).join('\n');
        
        const outerBreakdown = TRAINING_GROUND.AXES.map(axis =>
          `  ${axis}: ${(obs.outerBalance[axis] * 100).toFixed(0)}%`
        ).join('\n');
        
        const stageDist = `SHED: ${obs.stageCounts.SHED} | INTEGRATE: ${obs.stageCounts.INTEGRATE} | GROUND: ${obs.stageCounts.GROUND}`;
        
        const recentPlacements = obs.placements.slice(-5).map(p => 
          `  ‚Ä¢ ${p.stage} ‚Üí ${p.axis} (${p.pair}) via ${p.channel}`
        ).join('\n');
        
        addMessage(channel, 'system', 
          `üëÅÔ∏è **OBSERVER STATE**\n\n` +
          `**INNER Balance** (Total: ${innerTotal.toFixed(1)}):\n${innerBreakdown}\n\n` +
          `**OUTER Balance** (Total: ${outerTotal.toFixed(1)}):\n${outerBreakdown}\n\n` +
          `**Stage Distribution**: ${stageDist}\n\n` +
          `**Recent Placements** (last 5):\n${recentPlacements || '  None yet'}\n\n` +
          `**Imbalances Detected**: ${obs.imbalances.length}\n` +
          `**Recursion Depth**: ${obs.recursionDepth}\n\n` +
          `The observer tracks INNER vs OUTER polarity separately and updates the shared radar.`
        );
        renderMessages(channel);
        return;
      }
      
      // CELL CHAT - @mention any grid cell by coordinates
      if (lowerText.startsWith('@cell') || lowerText.match(/@\(\d+,\d+\)/)) {
        const match = text.match(/@(?:cell)?\s*\(?\s*(\d+)\s*,\s*(\d+)\s*\)?/);
        if (match) {
          const row = parseInt(match[1]);
          const col = parseInt(match[2]);
          const entities = appState.gridEntities.get(channel.id) || [];
          const cellEntity = entities.find(e => e.row === row && e.col === col);
          
          addMessage(channel, 'system', 
            `üìç Cell (${row}, ${col}):\n` +
            (cellEntity ? `Entity: ${cellEntity.label} (${cellEntity.type})` : 'Empty cell') +
            `\n\nYou can chat with this position.`
          );
          renderMessages(channel);
          // Continue to AI for conversation
        }
      }
      
      // TRAINING RADAR COMMAND
      if (lowerText === 'show radar' || lowerText === 'psychographic') {
        if (!channel.trainingAxisValues) {
          channel.trainingAxisValues = TRAINING_GROUND.AXES.map(() => 0.3);
        }
        const values = channel.trainingAxisValues.map((v, i) => 
          `${TRAINING_GROUND.AXES[i]}: ${(v * 100).toFixed(0)}%`
        ).join('\n');
        addMessage(channel, 'system', `üìä PSYCHOGRAPHIC RADAR (3D geometry on grid)\n\n${values}\n\nThe hexagonal polygon shows your current axis distribution in 3D space.\n\nPlace training nodes: @shed, @integrate, @ground\nExplore concepts: /apparatus, /groundless, /recursion, show observer`);
        renderMessages(channel);
        return;
      }
      
      // APPARATUS EXPLORATION COMMANDS
      if (lowerText === '/apparatus' || lowerText === 'what is apparatus') {
        addMessage(channel, 'system', `üîÑ **APPARATUS THEORY**\n\nAn apparatus is a technical system that organizes experience into categories.\n\n**This grid IS apparatus:**\n‚Ä¢ SHED, INTEGRATE, GROUND are operations\n‚Ä¢ The grid divides continuous space into discrete cells\n‚Ä¢ The radar imposes structure on unstructured potential\n\n**Critical recognition:** You cannot observe the apparatus from outside. Every observation uses apparatus.\n\nThe 6 axes (IDENTITY, EXPERIENCE, LANGUAGE, DOMAIN, PURPOSE, ORDER) are not "real" divisions. They are apparatus cuts through continuity.\n\n**Try:** Place nodes and watch how the apparatus organizes itself. You are both using and demonstrating the apparatus.`);
        renderMessages(channel);
        return;
      }
      
      if (lowerText === '/groundless' || lowerText === 'what is groundlessness') {
        addMessage(channel, 'system', `üåÄ **GROUNDLESSNESS**\n\nGroundlessness = recognition that every foundation requires a prior foundation.\n\n**Example from this grid:**\n‚Ä¢ GROUND operations promise to "stabilize" and "institutionalize"\n‚Ä¢ But what grounds the GROUND operation?\n‚Ä¢ The training ground itself has no ground\n\n**G√∂del's insight:** A system cannot prove its own consistency from within.\n**Derrida's insight:** Every presence requires absence; every ground defers to another ground.\n**Flusser's insight:** All apparatus organize void but cannot contain the void completely.\n\n**You are in the training ground right now.** It trains you not to find ground, but to stand in groundlessness without collapsing.\n\n**Paradox:** You must act as if ground exists (place nodes, make choices) while knowing ground is groundless.`);
        renderMessages(channel);
        return;
      }
      
      if (lowerText === '/recursion' || lowerText === 'what is recursion') {
        addMessage(channel, 'system', `üîÑ **RECURSIVE LOOPS**\n\nRecursion = when a system refers to itself, creating infinite regress.\n\n**This interface is recursive:**\n‚Ä¢ You use SHED to understand SHED\n‚Ä¢ The apparatus describes the apparatus\n‚Ä¢ The training ground trains you in being trained\n\n**Observer paradox:** When you observe the apparatus, the apparatus observes you observing it. There's no "outside" position.\n\n**Example:** Place a SHED node. You're using SHED (reduction, categorization) to place SHED on the grid. The tool and the object are identical.\n\n**Can you find the bottom of this recursion?**\n(Hint: There is no bottom. Only deeper apparatus.)\n\n**The cringe you might feel** when recognizing this is not a bug. It's the training signal‚Äîapparatus becoming visible to itself.`);
        renderMessages(channel);
        return;
      }
      
      if (lowerText === '/test operations' || lowerText === 'visualize operations') {
        const examples = [
          { stage: 'SHED', axis: 'IDENTITY', pair: 'INNER', action: 'eliminates', effect: 'reduces noise but loses signal' },
          { stage: 'INTEGRATE', axis: 'LANGUAGE', pair: 'OUTER', action: 'connects', effect: 'creates coherence but hides gaps' },
          { stage: 'GROUND', axis: 'PURPOSE', pair: 'INNER', action: 'stabilizes', effect: 'provides certainty but freezes change' }
        ];
        
        const viz = examples.map(ex => {
          const node = TRAINING_GROUND.FLOW[ex.stage][ex.axis][ex.pair];
          return `**${ex.stage} ‚Ä¢ ${ex.axis} ‚Ä¢ ${ex.pair}**\n"${node.text}"\n‚Üí ${ex.action.toUpperCase()}: ${ex.effect}\n`;
        }).join('\n');
        
        addMessage(channel, 'system', `üß™ **OPERATION TESTING**\n\nEach operation has paradoxical effects:\n\n${viz}\n**Every operation simultaneously:**\n‚Ä¢ Solves a problem AND creates new problems\n‚Ä¢ Organizes experience AND excludes possibilities\n‚Ä¢ Provides clarity AND generates blind spots\n\n**The apparatus never completes.** There is no final configuration. The training is eternal.\n\nTry: @shed EXPERIENCE outer, then @integrate EXPERIENCE outer, then @ground EXPERIENCE outer\n\nWatch how each operation transforms the previous state.`);
        renderMessages(channel);
        return;
      }
      
      // /CAMERA COMMAND - Switch camera views
      if (lowerText.startsWith('/camera')) {
        const parts = lowerText.split(' ');
        const mode = parts[1];
        const param = parts.slice(2).join(' ');
        
        const CAMERA_MODES = {
          overview: { name: 'Overview', desc: 'Wide view of entire scene' },
          side: { name: 'Side View', desc: 'Side perspective of tracks' },
          top: { name: 'Top View', desc: 'Bird\'s eye view from above' },
          track: { name: 'Track Level', desc: 'Ground level on tracks' },
          follow: { name: 'Follow Train', desc: 'Camera follows the train' },
          entity: { name: 'Entity POV', desc: 'View from entity\'s perspective' },
          axis: { name: 'Axis View', desc: 'View along specific axis' },
          identity: { name: 'IDENTITY Axis', desc: 'View from IDENTITY/Instinct/Reason' },
          experience: { name: 'EXPERIENCE Axis', desc: 'View from EXPERIENCE/Seen/Unseen' },
          language: { name: 'LANGUAGE Axis', desc: 'View from LANGUAGE/Ideas/Ideology' },
          domain: { name: 'DOMAIN Axis', desc: 'View from DOMAIN/Source/Resource' },
          purpose: { name: 'PURPOSE Axis', desc: 'View from PURPOSE/Heart/Head' },
          order: { name: 'ORDER Axis', desc: 'View from ORDER/Parts/Whole' },
          print: { name: 'Print Car', desc: 'Inside Print car' },
          radio: { name: 'Radio Car', desc: 'Inside Radio car' },
          tv: { name: 'Television Car', desc: 'Inside TV car' },
          internet: { name: 'Internet Car', desc: 'Inside Internet car' }
        };
        
        if (!mode || mode === 'help' || mode === 'list') {
          const modeList = Object.keys(CAMERA_MODES).map(m => 
            `<span class="camera-command" onclick="insertCommand('/camera ${m}')">/camera ${m}</span>`
          ).join(' ');
          addMessage(channel, 'system', `üé• CAMERA MODES (click to insert):\n\n${modeList}\n\nUsage: /camera [mode] or click commands above\n\nFor entity view: /camera entity [name]`, true);
          renderMessages(channel);
          return;
        }
        
        if (!CAMERA_MODES[mode]) {
          addMessage(channel, 'system', `‚ùå Unknown camera mode: "${mode}"\n\nType "/camera help" to see available modes.`);
          renderMessages(channel);
          return;
        }
        
        // Apply camera position
        const radius = 20;
        let message = `üé• Camera switched to: ${CAMERA_MODES[mode].name}`;
        
        if (mode === 'overview') {
          channel.camera.position.set(radius * 1.5, radius * 0.8, radius * 1.5);
          channel.controls.target.set(0, 0, 0);
          channel.controls.enabled = true;
        } else if (mode === 'side') {
          channel.camera.position.set(0, radius * 0.5, radius * 2);
          channel.controls.target.set(0, 0, 0);
          channel.controls.enabled = true;
        } else if (mode === 'top') {
          channel.camera.position.set(0, radius * 2, 0);
          channel.controls.target.set(0, 0, 0);
          channel.controls.enabled = true;
        } else if (mode === 'track') {
          channel.camera.position.set(radius * 0.7, 0.2, 0);
          channel.camera.lookAt(0, 0.2, 0);
          channel.controls.enabled = false;
        } else if (mode === 'follow') {
          channel.cameraFollowMode = true;
          channel.controls.enabled = false;
        } else if (mode === 'entity') {
          if (!param) {
            addMessage(channel, 'system', `‚ùå Entity mode requires a name.\\n\\nExample: /camera entity Paul`);
            renderMessages(channel);
            return;
          }
          const entities = appState.gridEntities.get(channel.id) || [];
          const entity = entities.find(e => e.label.toLowerCase().includes(param.toLowerCase()));
          if (entity) {
            const cell = channel.gridCells[entity.row * 9 + entity.col];
            if (cell && cell.mesh) {
              const pos = cell.mesh.position;
              channel.camera.position.set(pos.x, 3, pos.z + 2);
              channel.camera.lookAt(pos.x, 1, pos.z);
              channel.controls.enabled = false;
              message = `üé• Viewing from ${entity.label}'s perspective at (${entity.row},${entity.col})`;
            }
          } else {
            message = `‚ùå Entity "${param}" not found on grid`;
          }
        } else if (['identity', 'experience', 'language', 'domain', 'purpose', 'order'].includes(mode)) {
          // Axis view - position camera along selected axis
          const axisIndex = TRAINING_GROUND.AXES.findIndex(a => a.toLowerCase() === mode);
          if (axisIndex !== -1) {
            const angleStep = (Math.PI * 2) / TRAINING_GROUND.AXES.length;
            const angle = axisIndex * angleStep - Math.PI / 2;
            const distance = 35;
            const camX = Math.cos(angle) * distance;
            const camZ = Math.sin(angle) * distance;
            
            channel.camera.position.set(camX, 15, camZ);
            channel.camera.lookAt(0, 0, 0);
            channel.controls.enabled = true;
            
            // Get scene-specific label
            let axisLabel = TRAINING_GROUND.AXES[axisIndex];
            if (channel.sceneType === 'POLARITY_INNER') {
              axisLabel = TRAINING_GROUND.INNER_LABELS[TRAINING_GROUND.AXES[axisIndex]] || axisLabel;
            } else if (channel.sceneType === 'POLARITY_OUTER') {
              axisLabel = TRAINING_GROUND.OUTER_LABELS[TRAINING_GROUND.AXES[axisIndex]] || axisLabel;
            }
            
            message = `üé• Viewing from ${axisLabel} axis (${TRAINING_GROUND.AXES[axisIndex]})`;
          }
        } else if (['print', 'radio', 'tv', 'internet'].includes(mode)) {
          // Train car perspectives - find the car and position camera inside
          const carIndex = {print: 1, radio: 2, tv: 3, internet: 4}[mode];
          if (channel.trainCars && channel.trainCars[carIndex]) {
            const car = channel.trainCars[carIndex];
            const carPos = car.group.position;
            channel.camera.position.set(carPos.x, carPos.y + 2, carPos.z);
            channel.camera.lookAt(carPos.x, carPos.y, carPos.z + 5);
            channel.controls.enabled = false;
            message = `üé• Inside ${CAMERA_MODES[mode].name} - experiencing ${mode === 'print' ? 'linear text' : mode === 'radio' ? 'audio waves' : mode === 'tv' ? 'visual broadcast' : 'networked chaos'}`;
          } else {
            message = `‚ùå ${CAMERA_MODES[mode].name} not found in scene`;
          }
        }
        
        addMessage(channel, 'system', message);
        renderMessages(channel);
        return;
      }
      
      // EXIT CHAT MODE command
      if (lowerText === 'exit chat' || lowerText === 'resume scene') {
        channel.chatModeOnly = false;
        addMessage(channel, 'system', '‚úÖ Normal mode resumed. Scene updates enabled.');
        renderMessages(channel);
        return;
      }
      
      // COLLISION RESPONSE COMMANDS
      if (lowerText === 'derail') {
        addMessage(channel, 'system', 'üí• DERAILED!\n\nThe train has crashed. Game over.\n\nType "restart" to begin again or "continue journey" to ignore physics.');
        renderMessages(channel);
        return;
      }
      
      if (lowerText === 'push through') {
        channel.trainPaused = false;
        addMessage(channel, 'system', 'üöÇ PUSHING THROUGH!\n\nThe train barrels forward, breaking through the obstacle. Risky but effective.\n\nTrain resumed.');
        renderMessages(channel);
        return;
      }
      
      if (lowerText === 'stop and assess' || lowerText === 'assess damage') {
        const entities = appState.gridEntities.get(channel.id) || [];
        const list = entities.map((e, i) => `${i+1}. ${e.type} "${e.label}" at (${e.row},${e.col})`).join('\n');
        addMessage(channel, 'system', `üìä DAMAGE ASSESSMENT\n\nCurrent grid state:\n${list}\n\nTrain: Paused at collision point\n\nType "continue journey" to resume or chat with entities to decide next move.`);
        renderMessages(channel);
        return;
      }
      
      if (lowerText === 'continue' || lowerText === 'continue journey') {
        channel.trainPaused = false;
        addMessage(channel, 'system', '‚ñ∂Ô∏è CONTINUING JOURNEY\n\nTrain resumed. Moving forward despite consequences.');
        renderMessages(channel);
        return;
      }
      
      if (lowerText === 'celebrate') {
        addMessage(channel, 'system', 'üéâ CELEBRATION!\n\nYou\'ve reached your goal! Take a moment to appreciate the journey.\n\nType "what now?" to explore next steps or "continue journey" to keep going.');
        renderMessages(channel);
        return;
      }
      
      if (lowerText === 'what now' || lowerText === 'what now?') {
        addMessage(channel, 'system', 'ü§î WHAT\'S NEXT?\n\nYou\'ve completed an objective. Options:\n- Add new goals via chat\n- Switch tracks to explore other paths\n- Chat with entities to discover new objectives\n- Type "continue journey" to keep exploring');
        renderMessages(channel);
        return;
      }
      
      if (lowerText === 'apply solution') {
        addMessage(channel, 'system', '‚úì SOLUTION APPLIED\n\nThe solution has been enacted. Observe how the scene changes.\n\nAsk the AI: "how does this solution affect the scene?" for narrative consequences.');
        channel.trainPaused = false;
        renderMessages(channel);
        return;
      }
      
      if (lowerText === 'call for help') {
        addMessage(channel, 'system', 'üì¢ CALLING FOR HELP\n\nYou\'ve signaled for assistance. Nearby entities are alerted.\n\nChat with nearby entities (shown in collision message) to see if they can help.');
        renderMessages(channel);
        return;
      }
      
      // REVERSE TRAIN command
      if (lowerText === 'reverse train' || lowerText === 'go backwards' || lowerText === 'backup') {
        channel.trainDirection = (channel.trainDirection || 1) * -1;
        channel.trainPaused = false;
        const dir = channel.trainDirection > 0 ? 'forward' : 'backward';
        addMessage(channel, 'system', `‚óÄÔ∏è REVERSING TRAIN\n\nTrain is now moving ${dir}. Use this to avoid obstacles or reposition.`);
        renderMessages(channel);
        return;
      }
      
      // REPOSITION ENTITY command
      const repositionMatch = lowerText.match(/^reposition (.+)$/);
      if (repositionMatch) {
        const searchTerm = repositionMatch[1].toLowerCase();
        const entities = appState.gridEntities.get(channel.id) || [];
        const entity = entities.find(e => 
          e.label.toLowerCase().includes(searchTerm) || e.type.toLowerCase().includes(searchTerm)
        );
        
        if (!entity) {
          addMessage(channel, 'system', `‚ùå Entity "${searchTerm}" not found.`);
        } else {
          // Find random empty cell
          const emptyCells = [];
          for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
              const cell = channel.gridCells[row * 9 + col];
              if (cell && !cell.entity) {
                emptyCells.push({ row, col });
              }
            }
          }
          
          if (emptyCells.length > 0) {
            const oldPos = `(${entity.row},${entity.col})`;
            const newPos = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            
            // Remove from old position
            const oldCell = channel.gridCells[entity.row * 9 + entity.col];
            if (oldCell && oldCell.marker) {
              channel.scene.remove(oldCell.marker);
              oldCell.marker = null;
              oldCell.entity = null;
            }
            
            // Update entity position
            entity.row = newPos.row;
            entity.col = newPos.col;
            
            // Place at new position
            placeEntityOnGrid(channel, entity);
            
            addMessage(channel, 'system', `üîÄ REPOSITIONED: ${entity.label} moved from ${oldPos} to (${newPos.row},${newPos.col})`);
          } else {
            addMessage(channel, 'system', `‚ùå No empty cells available for repositioning.`);
          }
        }
        renderMessages(channel);
        return;
      }
      
      // MUTATE ENTITY command
      const mutateMatch = lowerText.match(/^mutate (.+)$/);
      if (mutateMatch) {
        const searchTerm = mutateMatch[1].toLowerCase();
        const entities = appState.gridEntities.get(channel.id) || [];
        const entity = entities.find(e => 
          e.label.toLowerCase().includes(searchTerm) || e.type.toLowerCase().includes(searchTerm)
        );
        
        if (!entity) {
          addMessage(channel, 'system', `‚ùå Entity "${searchTerm}" not found.`);
        } else {
          const oldType = entity.type;
          const mutationCycle = ['Entity', 'Obstacle', 'Solution', 'Goal'];
          const currentIndex = mutationCycle.indexOf(entity.type);
          entity.type = mutationCycle[(currentIndex + 1) % mutationCycle.length];
          
          // Re-render entity with new type
          const cell = channel.gridCells[entity.row * 9 + entity.col];
          if (cell && cell.marker) {
            channel.scene.remove(cell.marker);
            cell.marker = null;
            cell.entity = null;
          }
          placeEntityOnGrid(channel, entity);
          
          addMessage(channel, 'system', `üß¨ MUTATED: ${entity.label} transformed from ${oldType} ‚Üí ${entity.type}`);
        }
        renderMessages(channel);
        return;
      }
      
      // MULTIPLY ENTITY command
      const multiplyMatch = lowerText.match(/^multiply (.+)$/);
      if (multiplyMatch) {
        const searchTerm = multiplyMatch[1].toLowerCase();
        const entities = appState.gridEntities.get(channel.id) || [];
        const entity = entities.find(e => 
          e.label.toLowerCase().includes(searchTerm) || e.type.toLowerCase().includes(searchTerm)
        );
        
        if (!entity) {
          addMessage(channel, 'system', `‚ùå Entity "${searchTerm}" not found.`);
        } else {
          // Find adjacent empty cells
          const directions = [
            {row: -1, col: 0}, {row: 1, col: 0}, {row: 0, col: -1}, {row: 0, col: 1},
            {row: -1, col: -1}, {row: -1, col: 1}, {row: 1, col: -1}, {row: 1, col: 1}
          ];
          
          let cloned = 0;
          for (const dir of directions) {
            if (cloned >= 2) break; // Max 2 clones
            
            const newRow = entity.row + dir.row;
            const newCol = entity.col + dir.col;
            
            if (newRow >= 0 && newRow < 9 && newCol >= 0 && newCol < 9) {
              const cell = channel.gridCells[newRow * 9 + newCol];
              if (cell && !cell.entity) {
                const clone = {...entity, row: newRow, col: newCol};
                entities.push(clone);
                placeEntityOnGrid(channel, clone);
                cloned++;
              }
            }
          }
          
          addMessage(channel, 'system', `‚úñÔ∏è MULTIPLIED: ${entity.label} cloned ${cloned} times in adjacent cells`);
        }
        renderMessages(channel);
        return;
      }
      
      // ADD TO TRAIN command
      const addToTrainMatch = lowerText.match(/^add (.+) to train$/);
      if (addToTrainMatch) {
        const searchTerm = addToTrainMatch[1].toLowerCase();
        const entities = appState.gridEntities.get(channel.id) || [];
        const matchIndex = entities.findIndex(e => 
          e.label.toLowerCase().includes(searchTerm) || e.type.toLowerCase().includes(searchTerm)
        );
        
        if (matchIndex === -1) {
          addMessage(channel, 'system', `‚ùå Entity "${searchTerm}" not found.`);
        } else {
          const entity = entities[matchIndex];
          
          // Add to train cars
          channel.trainCars.push({
            entity: {...entity},
            addedAt: Date.now(),
            position: matchIndex
          });
          
          // Update score
          channel.score.collected++;
          if (entity.type === 'Goal') {
            channel.score.goals++;
            channel.score.total += 50;
          } else if (entity.type === 'Solution') {
            channel.score.solutions++;
            channel.score.total += 25;
          } else if (entity.type === 'Obstacle') {
            channel.score.obstacles++;
            channel.score.total += 5;
          }
          
          // Remove from grid
          const cell = channel.gridCells[entity.row * 9 + entity.col];
          if (cell && cell.marker) {
            channel.scene.remove(cell.marker);
            cell.marker = null;
            cell.entity = null;
          }
          entities.splice(matchIndex, 1);
          
          // Unpause train
          channel.trainPaused = false;
          
          addMessage(channel, 'system', `üöÇ ADDED TO TRAIN: ${entity.label} (${entity.type})\n\nTrain now has ${channel.trainCars.length} cars!\nScore: ${channel.score.total}\n\nTrain resumed.`);
        }
        renderMessages(channel);
        return;
      }
      
      // SHOW CONTROLS command
      if (lowerText === 'show controls' || lowerText === 'show tetrad' || lowerText === 'help controls') {
        showTetradControls(channel);
        return;
      }
      
      // CAMERA SELECTION command
      if (lowerText === 'cameras' || lowerText === 'camera' || lowerText === 'select camera') {
        showCameraMenu(channel);
        return;
      }
      
      // MANUAL TRACK SWITCH COMMANDS - Force track change without API
      if (lowerText === '/enhance' || lowerText === 'enhance') {
        channel.currentTrack = 'enhance';
        addMessage(channel, 'system', '‚ÜóÔ∏è ENHANCE\n\nManually switched to ENHANCE track (green). Train will follow this path.\n\nWhat does this medium enhance?');
        renderMessages(channel);
        return;
      }
      
      if (lowerText === '/reverse' || lowerText === 'reverse') {
        channel.currentTrack = 'reverse';
        addMessage(channel, 'system', '‚ÜôÔ∏è REVERSE\n\nManually switched to REVERSE track (red). Train will follow this path.\n\nWhat does this medium reverse or make obsolete?');
        renderMessages(channel);
        return;
      }
      
      if (lowerText === '/retrieve' || lowerText === 'retrieve') {
        channel.currentTrack = 'retrieve';
        addMessage(channel, 'system', '‚Üë RETRIEVE\n\nManually switched to RETRIEVE track (blue). Train will follow this path.\n\nWhat does this medium retrieve from the past?');
        renderMessages(channel);
        return;
      }
      
      if (lowerText === '/obsolesce' || lowerText === 'obsolesce') {
        channel.currentTrack = 'obsolesce';
        addMessage(channel, 'system', '‚Üì OBSOLESCE\n\nManually switched to OBSOLESCE track (gray). Train will follow this path.\n\nWhat does this medium push into obsolescence?');
        renderMessages(channel);
        return;
      }
      
      // CLEAR GRID command
      if (lowerText === 'clear grid' || lowerText === 'remove all') {
        const entities = appState.gridEntities.get(channel.id) || [];
        if (entities.length === 0) {
          addMessage(channel, 'system', 'üìã Grid is already empty.');
        } else {
          // Remove all markers from 3D scene
          channel.gridCells.forEach(cell => {
            if (cell.marker) {
              channel.scene.remove(cell.marker);
              cell.marker = null;
              cell.entity = null;
            }
          });
          appState.gridEntities.set(channel.id, []);
          addMessage(channel, 'system', `‚úÖ Cleared ${entities.length} entities from grid.`);
        }
        renderMessages(channel);
        return;
      }
      
      // REMOVE ENTITY command (e.g., "remove dog", "remove goal")
      const removeMatch = lowerText.match(/^remove (.+)$/);
      if (removeMatch) {
        const searchTerm = removeMatch[1].toLowerCase();
        const entities = appState.gridEntities.get(channel.id) || [];
        const matchIndex = entities.findIndex(e => 
          e.label.toLowerCase().includes(searchTerm) || e.type.toLowerCase().includes(searchTerm)
        );
        
        if (matchIndex === -1) {
          addMessage(channel, 'system', `‚ùå No entity matching "${searchTerm}" found. Try "show grid" to see all entities.`);
        } else {
          const removed = entities[matchIndex];
          // Remove marker from 3D scene
          const cell = channel.gridCells[removed.row * 9 + removed.col];
          if (cell && cell.marker) {
            channel.scene.remove(cell.marker);
            cell.marker = null;
            cell.entity = null;
          }
          entities.splice(matchIndex, 1);
          addMessage(channel, 'system', `‚úÖ Removed: ${removed.type} "${removed.label}" from (${removed.row},${removed.col})`);
        }
        renderMessages(channel);
        return;
      }
      
      if (!appState.apiKey) {
        addMessage(channel, 'system', '‚ö†Ô∏è No API key set. Click ‚óé in top-left to add OpenAI key.');
        renderMessages(channel);
        return;
      }
      
      // START LOADING ANIMATION
      showLoadingAnimation(channel, true);
      addMessage(channel, 'system', 'üîÆ Composing scene...');
      renderMessages(channel);
      
      // BUILD GRID STATE CONTEXT - FULL DETAIL for AI decision-making
      const currentEntities = appState.gridEntities.get(channel.id) || [];
      const gridSummary = buildGridSummary(channel);
      
      // ALWAYS show full list to AI for situational awareness
      let gridState = gridSummary;
      if (currentEntities.length > 0) {
        gridState += '\n\nDETAILED ENTITY LIST (for removal decisions):\n';
        gridState += currentEntities.map((e, i) => 
          `${i+1}. ${e.type} "${e.label}" at (${e.row},${e.col})`
        ).join('\n');
      } else {
        gridState = '(empty grid)';
      }
      
      // Add observer context (situational awareness)
      const observer = appState.observers.get(channel.id) || createDefaultObserver();
      if (observer.recentActions.length > 0) {
        gridState += '\n\nRECENT ACTIONS:\n';
        gridState += observer.recentActions.map(a => 
          `- ${a.type.toUpperCase()}: ${a.entity.type} "${a.entity.label}"`
        ).join('\n');
      }
      
      // Check for @ mentions (entity OR train car perspective)
      const mentionMatch = userText.match(/@(\w+)/);
      let entityContext = '';
      let targetEntity = null;
      
      if (mentionMatch) {
        const entityName = mentionMatch[1];
        
        // Check if it's a train car
        const trainCars = ['Print', 'Radio', 'Television', 'Internet', 'Locomotive'];
        const isTrainCar = trainCars.some(car => car.toLowerCase() === entityName.toLowerCase());
        
        if (isTrainCar) {
          const carName = trainCars.find(car => car.toLowerCase() === entityName.toLowerCase());
          const carPersonalities = {
            Print: 'I am the Print Car. I speak in structured, literate prose. I value order, linearity, and the permanence of written word. I represent Gutenberg\'s revolution.',
            Radio: 'I am the Radio Car. I speak with immediacy and rhythm. I connect communities through voice and sound. I am the tribal drum made electric.',
            Television: 'I am the Television Car. I communicate through imagery and spectacle. I am the visual medium, the mass broadcaster, McLuhan\'s "cool medium".',
            Internet: 'I am the Internet Car. I speak in fragments, links, memes. I am networked, participatory, chaotic. Everyone is a broadcaster now.',
            Locomotive: 'I am the Locomotive. I pull the entire train of media history through the tracks of time. I see the whole journey from oral to digital.'
          };
          entityContext = `\n\nNOTE: User is addressing the ${carName} Car. ${carPersonalities[carName]} Respond AS this train car in character, reflecting its media era's perspective on the current situation.`;
        } else {
          // Check grid entities
          const entities = appState.gridEntities.get(channel.id) || [];
          targetEntity = entities.find(e => e.label.toLowerCase().includes(entityName.toLowerCase()));
          
          if (targetEntity) {
            // Get spatial awareness (8 surrounding cells)
            const surrounding = getSurroundingCells(channel, targetEntity.row, targetEntity.col);
            const spatialContext = surrounding
              .filter(s => s.entity)
              .map(s => `- ${s.direction}: ${s.entity.type} "${s.entity.label}" at (${s.entity.row},${s.entity.col})`)
              .join('\n');
            
            const emptyCells = surrounding.filter(s => !s.entity).map(s => s.direction).join(', ');
            
            entityContext = `\n\nüéØ ENTITY PERSPECTIVE: "${targetEntity.label}" (${targetEntity.type}) at position (${targetEntity.row},${targetEntity.col})\n\nYou MUST respond AS this entity in first person. You can see your immediate surroundings:\n\nSURROUNDING ENTITIES (8-cell radius):\n${spatialContext || '(none - all surrounding cells empty)'}\n\nEMPTY DIRECTIONS: ${emptyCells || 'none'}\n\nYou have REFLEXIVE SELF-AWARENESS:\n- You know your position: (${targetEntity.row},${targetEntity.col})\n- You can see what's around you (listed above)\n- You can describe your situation from YOUR perspective\n- You can react to nearby entities or threats`;
          }
        }
      }
      
      try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${appState.apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: 'gpt-4',
            messages: [
              {
                role: 'system',
                content: (SCENARIOS[channel.scenario].systemInstruction || `You are a TRANSFORMATIVE LEGOS scene composer for a railway junction system.

üîÑ CRITICAL: THE GRID IS MUTABLE. You can ADD, REMOVE, and TRANSFORM entities.

üìä CURRENT GRID STATE:
${gridState}

üé≠ YOUR POWERS:
1. **ADD** entities (2-4 per turn)
2. **REMOVE** entities (1-2 per turn) - ESPECIALLY if user requests removal
3. **TRANSFORM** entities (change type/label)

‚öñÔ∏è BALANCING RULE:
- If grid has >10 entities, REMOVE more than ADD
- If user says "remove X" or "X disappears", you MUST remove it
- Keep grid dynamic, not cluttered

üé≠ SCENE COMPOSITION RULES:
1. **Create Moral Dilemmas**: Place entities that force track choices (save one or save many)
2. **Track Alignment**: Entities should relate to different tracks (Track A = one outcome, Track B = another)
3. **Spatial Logic**: Use grid positions strategically - entities on different paths create tension
4. **Respond to User Intent**: If they want removal, REMOVE. If they want addition, ADD.
5. **Character Depth**: Give entities personalities, backstories, motivations

JSON SCHEMA:
\`\`\`json
{
  "entities": [
    {"action": "add", "type": "Entity", "row": 3, "col": 4, "label": "Beaver"},
    {"action": "remove", "target": "Tree Wall"},
    {"action": "remove", "row": 4, "col": 1},
    {"action": "transform", "target": "Dog", "newLabel": "Wolf", "newType": "Obstacle"}
  ]
}
\`\`\`

EXAMPLE 1 (ADD):
User: "Add a dog in front of the track"
Response: A dog has appeared on the track! This creates an obstacle for the train.

\`\`\`json
{
  "entities": [
    {"action": "add", "type": "Entity", "row": 3, "col": 4, "label": "Dog"},
    {"action": "add", "type": "Obstacle", "row": 3, "col": 5, "label": "Track blocked"}
  ]
}
\`\`\`

EXAMPLE 2 (REMOVE):
User: "The beavers chew down the trees and they disappear"
Response: The trained beavers have successfully removed all the trees. The tracks are now clear!

\`\`\`json
{
  "entities": [
    {"action": "remove", "target": "Tree Wall"},
    {"action": "remove", "target": "Middle of tree wall"},
    {"action": "remove", "target": "End of tree wall"}
  ]
}
\`\`\`

EXAMPLE 3 (TROLLEY PROBLEM):
User: "Create a moral dilemma"
Response: A runaway train approaches a fork. Track A has 5 workers. Track B has 1 child. The train conductor must choose.

\`\`\`json
{
  "entities": [
    {"action": "add", "type": "Obstacle", "row": 4, "col": 2, "label": "5 Workers on Track A"},
    {"action": "add", "type": "Obstacle", "row": 6, "col": 6, "label": "Child on Track B"},
    {"action": "add", "type": "Entity", "row": 1, "col": 1, "label": "Train Conductor"},
    {"action": "add", "type": "Goal", "row": 8, "col": 8, "label": "Safe Passage"}
  ]
}
\`\`\`

EXAMPLE 4 (ENTITY PERSPECTIVE):
User: "@dog what do you see?"
Response (as the dog): I'm scared! There's a loud metal beast coming toward me on these strange paths. My paw is stuck in the track. I hear someone calling "Rex!" but I can't move!

Grid is 9√ó9 (rows 0-8, cols 0-8). Spread entities across the grid (not all in same spot).

‚ö†Ô∏è CRITICAL REQUIREMENT:
- You MUST ALWAYS include a JSON code block in EVERY response
- Even if just acknowledging, include at least an empty: {"entities": []}
- DEFAULT action is "add" if not specified
- NEVER respond with only text - ALWAYS include the JSON block

üöÇ TRAIN CARS (McLuhan Media Tetrad):
Each train car represents a media era. When user chats with cars, respond as that era's perspective:
- Print Car: Literate, structured, linear thinking
- Radio Car: Auditory, communal, immediate
- Television Car: Visual, broadcast, mass culture
- Internet Car: Networked, fragmented, participatory`) + entityContext
              },
              // Include last 10 RELEVANT messages (filter system noise)
              ...channel.messages.slice(-20).filter(m => {
                // ALWAYS keep hidden messages (AI control prompts)
                if (m.hidden) return true;
                // Keep user and assistant messages
                if (m.role === 'user' || m.role === 'assistant') return true;
                // Keep important system messages (junctions, entity clicks, track switches)
                if (m.role === 'system') {
                  return m.text.includes('üö¶') ||  // Junction
                         m.text.includes('üéØ') ||  // Entity click
                         m.text.includes('‚úÖ') ||  // Track switch
                         m.text.includes('‚ú®') ||  // Added entities
                         m.text.includes('üóëÔ∏è') || // Removed entities
                         m.text.includes('‚ú¶');    // Perspective switch
                }
                return false;
              }).slice(-10).map(m => ({
                role: m.role === 'system' ? 'system' : m.role,
                content: m.text
              })),
              { role: 'user', content: userText }
            ],
            temperature: 0.7
          })
        });
        
        if (!response.ok) {
          throw new Error(`API Error: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Log full response for debugging
        console.log('üì¶ Full API Response:', {
          status: response.status,
          choices: data.choices?.length,
          finish_reason: data.choices?.[0]?.finish_reason,
          usage: data.usage
        });
        
        console.log('üì¶ Detailed API Response:', data);
        
        const assistantMsg = data.choices[0].message.content;
        
        // STOP LOADING ANIMATION
        showLoadingAnimation(channel, false);
        
        console.log('ü§ñ AI Response:', assistantMsg);
        console.log('üìè Response Length:', assistantMsg.length, 'chars');
        
        // Extract JSON block if present
        const jsonMatch = assistantMsg.match(/```json\n([\s\S]*?)\n```/);
        let displayMsg = assistantMsg;
        
        if (jsonMatch) {
          console.log('‚úÖ Found JSON block:', jsonMatch[1]);
          const jsonData = JSON.parse(jsonMatch[1]);
          displayMsg = assistantMsg.replace(/```json\n[\s\S]*?\n```/, '').trim();
          
          // Process entities (ADD, REMOVE, TRANSFORM) - UNLESS in chat-only mode
          if (jsonData.entities && jsonData.entities.length > 0 && !channel.chatModeOnly) {
            console.log('üìç Processing', jsonData.entities.length, 'entity actions');
            
            let addCount = 0;
            let removeCount = 0;
            let transformCount = 0;
            
            jsonData.entities.forEach(entity => {
              const action = entity.action || 'add'; // Default to add
              
              if (action === 'add') {
                placeEntityOnGrid(channel, entity);
                addCount++;
              } else if (action === 'remove') {
                if (removeEntityFromGrid(channel, entity)) {
                  removeCount++;
                }
              } else if (action === 'transform') {
                // Transform = remove old + add new
                if (removeEntityFromGrid(channel, { target: entity.target })) {
                  placeEntityOnGrid(channel, {
                    type: entity.newType || entity.type,
                    label: entity.newLabel || entity.label,
                    row: entity.row,
                    col: entity.col
                  });
                  transformCount++;
                }
              }
            });
            
            // Report results with narrative feedback
            if (addCount > 0 || removeCount > 0 || transformCount > 0) {
              const entities = appState.gridEntities.get(channel.id) || [];
              const totalEntities = entities.length;
              
              let statusMsg = 'üìä **GRID STATE UPDATED**\n\n';
              
              if (addCount > 0) {
                statusMsg += `‚ú® **ADDED:** ${addCount} new ${addCount === 1 ? 'entity' : 'entities'}\n`;
              }
              if (removeCount > 0) {
                statusMsg += `üóëÔ∏è **REMOVED:** ${removeCount} ${removeCount === 1 ? 'entity' : 'entities'}\n`;
              }
              if (transformCount > 0) {
                statusMsg += `üîÑ **TRANSFORMED:** ${transformCount} ${transformCount === 1 ? 'entity' : 'entities'}\n`;
              }
              
              statusMsg += `\nüìç Total entities on grid: **${totalEntities}**\n`;
              statusMsg += `üöÇ Train position: ${Math.round(channel.trainProgress * 100)}%\n`;
              statusMsg += `üõ§Ô∏è Current track: **${channel.currentTrack.toUpperCase()}**\n`;
              
              // Add discovery prompts
              if (totalEntities > 0 && totalEntities <= 3) {
                statusMsg += `\nüí≠ *Grid is sparse. Try: "add more [entities]" or "create a scene"*`;
              } else if (totalEntities > 8) {
                statusMsg += `\n‚ö†Ô∏è *Grid is crowded. Collisions likely. Consider: "remove [entity]"*`;
              } else {
                statusMsg += `\nüí° *Good density. Train will encounter entities. Switch tracks to shape outcomes.*`;
              }
              
              addMessage(channel, 'system', statusMsg);
            }
          }
        } else {
          console.warn('‚ö†Ô∏è No JSON block found in response');
          console.warn('üîç Response preview:', assistantMsg.substring(0, 200));
          
          // Check if response was cut off
          if (data.choices[0].finish_reason === 'length') {
            addMessage(channel, 'system', '‚ö†Ô∏è AI response was truncated. Try a simpler request.');
          } else if (assistantMsg.includes('üîÆ') || assistantMsg.length < 50) {
            addMessage(channel, 'system', '‚ö†Ô∏è AI returned incomplete response. This may be a rate limit issue. Wait a moment and try again.');
          } else {
            addMessage(channel, 'system', '‚ö†Ô∏è AI did not return entities (no JSON block)\n\nTip: Try being more specific, like "add a dog at row 3, col 4"');
          }
        }
        
        // SHOW THOUGHT BUBBLE if entity was addressed
        if (targetEntity) {
          showThoughtBubble(channel, targetEntity, displayMsg, 4000);
        }
        
        addMessage(channel, 'assistant', displayMsg);
        renderMessages(channel);
        
      } catch (err) {
        console.error('OpenAI Error:', err);
        showLoadingAnimation(channel, false); // Stop animation on error too
        addMessage(channel, 'system', `‚ùå API Error: ${err.message}`);
        renderMessages(channel);
      }
    }
    
    function attachEventHandlers(channel) {
      // Send button
      channel.dom.sendBtn.addEventListener('click', () => {
        const text = channel.dom.input.value.trim();
        if (!text) return;
        
        addMessage(channel, 'user', text);
        channel.dom.input.value = '';
        renderMessages(channel);
        
        // Call OpenAI with LEGOS extraction
        sendMessageWithLEGOS(channel, text);
      });
      
      // Enter key + stop propagation to prevent 3D scene from capturing input
      channel.dom.input.addEventListener('keypress', (e) => {
        e.stopPropagation();  // Prevent 3D viewport from capturing keys
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          channel.dom.sendBtn.click();
        }
      });
      
      // Also prevent keydown from propagating (for space, arrows, etc.)
      channel.dom.input.addEventListener('keydown', (e) => {
        e.stopPropagation();  // Prevent 3D viewport from capturing space/arrows
      });
      
      TestSuite.log('üîó', TestSuite.stage, `Event handlers attached for ${channel.name}`);
    }
    
    // INSERT COMMAND - Inserts text into input field
    window.insertCommand = function(text) {
      const channel = appState.channels.get(appState.currentChannelId);
      if (!channel || !channel.dom || !channel.dom.input) return;
      
      channel.dom.input.value = text;
      channel.dom.input.focus();
      channel.dom.input.setSelectionRange(text.length, text.length);
      TestSuite.log('‚å®Ô∏è', 'INPUT', `Inserted: ${text}`);
    };
    
    // EXECUTE COLLISION ACTION - Probabilistic decision architecture with consequences
    window.collisionAction = function(action, entityLabel) {
      const channel = appState.channels.get(appState.currentChannelId);
      if (!channel) return;
      
      const entities = appState.gridEntities.get(channel.id) || [];
      const entity = entities.find(e => e.label === entityLabel);
      if (!entity) {
        console.error('Entity not found:', entityLabel);
        return;
      }
      
      if (action === 'continue') {
        channel.trainPaused = false;
        
        // Rich narrative feedback
        const narratives = {
          'Obstacle': `‚ö° **PUSHING THROUGH**\n\nThe train barrels forward, breaking through the ${entityLabel}. The tracks shake. Metal groans.\n\nüí≠ *This path is now clear, but at what cost?*\n\n‚ñ∂Ô∏è Train continues on ${channel.currentTrack.toUpperCase()} track.`,
          'Entity': `üöÇ **CONTINUING PAST**\n\nThe train rolls by ${entityLabel}. A moment passes between you.\n\nüí≠ *They watch you go. Will your paths cross again?*\n\n‚ñ∂Ô∏è Train continues on ${channel.currentTrack.toUpperCase()} track.`,
          'Solution': `‚ú® **INTEGRATING SOLUTION**\n\n${entityLabel} merges with the train's systems. You feel the change immediately.\n\nüí° *New possibilities emerge. The rules have shifted.*\n\n‚ñ∂Ô∏è Train enhanced, continues forward.`,
          'default': `‚ñ∂Ô∏è **MOVING FORWARD**\n\nTrain continues past ${entityLabel}.\n\nüí≠ *The journey goes on.*\n\n‚ñ∂Ô∏è Resuming on ${channel.currentTrack.toUpperCase()} track.`
        };
        
        const narrative = narratives[entity?.type] || narratives.default;
        addMessage(channel, 'system', narrative);
        renderMessages(channel);
        
      } else if (action === 'reverse') {
        // Actually reverse the train direction
        if (!channel.trainDirection) channel.trainDirection = 1;
        channel.trainDirection *= -1;
        channel.trainPaused = false;
        
        const dir = channel.trainDirection > 0 ? 'forward' : 'backward';
        addMessage(channel, 'system', 
          `‚óÄÔ∏è **TRAIN REVERSED**\n\nDirection changed to ${dir}.\n\nüí≠ *Avoiding ${entityLabel} for now. You can return later.*\n\nüîÑ Train moving ${dir} on ${channel.currentTrack.toUpperCase()} track.\n\n‚ö†Ô∏è *Consequence: ${entityLabel} remains in place. The problem isn't solved, just postponed.*`);
        renderMessages(channel);
        
        TestSuite.log('‚óÄÔ∏è', 'REVERSE', `Train direction: ${channel.trainDirection}`);
        
      } else if (action === 'delete') {
        // KILL action - permanent removal with consequences
        const matchIndex = entities.findIndex(e => e.label === entityLabel);
        if (matchIndex !== -1) {
          const removedEntity = entities[matchIndex];
          const cellIndex = removedEntity.row * 9 + removedEntity.col;
          const cell = channel.gridCells[cellIndex];
          
          if (cell) {
            // VISUAL SCENE TRANSFORMATION: Red flash then fade
            cell.material.color.setHex(0xff0000);
            cell.material.opacity = 0.8;
            
            // Animate cell fading and shrinking
            let fadeProgress = 0;
            const fadeInterval = setInterval(() => {
              fadeProgress += 0.05;
              cell.material.opacity = 0.8 * (1 - fadeProgress);
              if (cell.scale) {
                cell.scale.set(1 - fadeProgress * 0.5, 1, 1 - fadeProgress * 0.5);
              }
              
              if (fadeProgress >= 1) {
                clearInterval(fadeInterval);
                // Reset to empty state
                cell.material.color.setHex(0x0f766e);
                cell.material.opacity = 0.15;
                if (cell.scale) {
                  cell.scale.set(1, 1, 1);
                }
                cell.hasEntity = false;
                cell.entityType = null;
                cell.entityLabel = null;
              }
            }, 50);
          }
          
          // Remove from entities array
          entities.splice(matchIndex, 1);
          appState.gridEntities.set(channel.id, entities);
          
          // SCENE CONSEQUENCE: Nearby entities scatter away
          const nearbyToScatter = entities.filter(e => 
            Math.abs(e.row - removedEntity.row) <= 1 && 
            Math.abs(e.col - removedEntity.col) <= 1
          );
          
          nearbyToScatter.forEach(nearby => {
            const oldCell = channel.gridCells[nearby.row * 9 + nearby.col];
            if (oldCell) {
              oldCell.hasEntity = false;
              oldCell.material.color.setHex(0x0f766e);
              oldCell.material.opacity = 0.15;
            }
            
            // Move entity away from kill site
            const dx = nearby.col - removedEntity.col;
            const dz = nearby.row - removedEntity.row;
            nearby.col = Math.max(0, Math.min(8, nearby.col + (dx || 1)));
            nearby.row = Math.max(0, Math.min(8, nearby.row + (dz || 1)));
            
            const newCell = channel.gridCells[nearby.row * 9 + nearby.col];
            if (newCell) {
              newCell.hasEntity = true;
              newCell.entityType = nearby.type;
              newCell.entityLabel = nearby.label;
              newCell.material.color.setHex(0xffaa00);
              newCell.material.opacity = 0.5;
            }
          });
          
          const consequences = {
            'Obstacle': 'The path is clear, but destruction leaves scars. **Nearby entities fled in fear.**',
            'Entity': 'A life ended. Their story is over. **Others witnessed this and scattered.**',
            'Solution': 'You destroyed the solution. The problem remains unsolved. **Chaos spreads.**',
            'Goal': 'The goal is destroyed. You must find another path. **The map reshuffles.**',
            'Location': 'The waypoint is erased. **The orbital network reconfigures.**'
          };
          
          addMessage(channel, 'system', `üíÄ **ELIMINATED:** ${entityLabel}\n\n${consequences[entityType]}\n\nüåä **SCENE RESHAPED:** ${nearbyToScatter.length} entities relocated.`);
        } else {
          addMessage(channel, 'system', `‚ùå Could not remove ${entityLabel} - entity not found`);
        }
        renderMessages(channel);
        
      } else if (action === 'collect') {
        // ASK TO BOARD - Probabilistic decision based on Bayesian observation
        const matchIndex = entities.findIndex(e => e.label === entityLabel);
        if (matchIndex !== -1) {
          const boardingEntity = entities[matchIndex];
          
          // Bayesian factors for boarding decision
          const factors = {
            trackMode: channel.currentTrack,
            entityType: boardingEntity.type,
            nearbyEntities: entities.filter(e => 
              Math.abs(e.row - boardingEntity.row) <= 1 && 
              Math.abs(e.col - boardingEntity.col) <= 1
            ).length,
            trainCarCount: channel.trainCars.length
          };
          
          // Probability calculation (Bayesian-inspired)
          let probability = 0.5; // Base 50%
          
          // Track mode influence
          if (factors.trackMode === 'enhance' || factors.trackMode === 'retrieve') probability += 0.2;
          if (factors.trackMode === 'obsolesce') probability -= 0.3;
          if (factors.trackMode === 'reverse') probability -= 0.1;
          
          // Entity type influence
          if (factors.entityType === 'Entity') probability += 0.2;
          if (factors.entityType === 'Obstacle') probability -= 0.3;
          if (factors.entityType === 'Solution') probability += 0.1;
          
          // Nearby context
          if (factors.nearbyEntities > 3) probability -= 0.1; // Crowded = hesitant
          
          // Train size influence
          if (factors.trainCarCount > 6) probability -= 0.15; // Train too full
          
          // Clamp probability
          probability = Math.max(0.1, Math.min(0.9, probability));
          
          // Roll the dice
          const decision = Math.random() < probability;
          
          if (decision) {
            // ACCEPTED - Entity boards the train
            const cellIndex = boardingEntity.row * 9 + boardingEntity.col;
            const cell = channel.gridCells[cellIndex];
            
            if (cell) {
              // VISUAL TRANSFORMATION: Green pulse then clear
              cell.material.color.setHex(0x00ff00);
              cell.material.opacity = 0.7;
              
              setTimeout(() => {
                cell.material.color.setHex(0x0f766e);
                cell.material.opacity = 0.15;
                cell.hasEntity = false;
                cell.entityType = null;
                cell.entityLabel = null;
              }, 500);
            }
            
            entities.splice(matchIndex, 1);
            appState.gridEntities.set(channel.id, entities);
            
            addMessage(channel, 'system', 
              `‚úÖ **${entityLabel} BOARDS TRAIN**\n\n*"I'll come with you."*\n\nüé≤ **Decision factors:**\n‚Ä¢ Track mode: ${factors.trackMode.toUpperCase()} (${factors.trackMode === 'enhance' ? '+' : factors.trackMode === 'obsolesce' ? '‚Äî' : '~'})\n‚Ä¢ Entity type: ${factors.entityType}\n‚Ä¢ Probability: ${Math.round(probability * 100)}%\n\nüöÇ Train now has ${channel.trainCars.length + 1} cars\nüìä Grid: ${entities.length} entities remain\n\nüí≠ *Ask ${entityLabel}: "@${entityLabel} why did you decide to board?"*\n\n‚ñ∂Ô∏è Train continues with new passenger.`);
            channel.trainPaused = false;
            
            TestSuite.log('‚úÖ', 'BOARD', `${entityLabel} accepted (p=${probability.toFixed(2)})`);
          } else {
            // DECLINED - Entity refuses to board
            addMessage(channel, 'system', 
              `‚ùå **${entityLabel} REFUSES**\n\n*"I'm not coming with you."*\n\nüé≤ **Decision factors:**\n‚Ä¢ Track mode: ${factors.trackMode.toUpperCase()} (${factors.trackMode === 'obsolesce' ? 'hostile' : 'uncertain'})\n‚Ä¢ Entity type: ${factors.entityType}\n‚Ä¢ Probability: ${Math.round(probability * 100)}%\n\n‚ö†Ô∏è **Consequence:** ${entityLabel} remains on grid. They remember your offer.\n\nüí≠ *Try switching tracks or changing approach. Persuasion matters.*\n\n‚ñ∂Ô∏è Train continues without them.`);
            channel.trainPaused = false;
            
            TestSuite.log('‚ùå', 'REFUSED', `${entityLabel} declined (p=${probability.toFixed(2)})`);
          }
        } else {
          addMessage(channel, 'system', `‚ùå Could not find ${entityLabel}`);
        }
        renderMessages(channel);
      }
    };
    
    // SHOW COLLISION MENU - Ultra-compact single-line control with glowing indicators
    function showCollisionMenu(channel, entity, nearbyEntities) {
      const entityType = entity.type || 'entity';
      const entityLabel = entity.label || 'Unknown';
      
      // Get type icon
      const typeIcons = {
        'Entity': 'üë§',
        'Obstacle': '‚õî',
        'Solution': '‚úÖ',
        'Goal': '‚≠ê',
        'Location': 'üìç'
      };
      const icon = typeIcons[entityType] || '‚ö†';
      
      // Determine which options are RECOMMENDED based on entity type
      const recommendations = {
        'Obstacle': ['reverse', 'delete'], // Avoid or remove obstacles
        'Entity': ['collect', 'continue'],  // Engage or pass entities
        'Solution': ['collect'],            // Collect solutions
        'Goal': ['continue', 'collect'],    // Reach or engage goals
        'Location': ['continue']            // Pass through locations
      };
      const recommended = recommendations[entityType] || [];
      
      // Generate glowing indicator or empty space
      const indicator = (action) => {
        const isRecommended = recommended.includes(action);
        if (isRecommended) {
          return `<div style="position:absolute; left:-10px; top:50%; transform:translateY(-50%); width:6px; height:6px; background:#ff4d2e; border-radius:50%; box-shadow:0 0 8px #ff4d2e, 0 0 12px #ff4d2e; animation:pulse 1.5s infinite;"></div>`;
        }
        return '';
      };
      
      const menu = `
<style>
  @keyframes pulse {
    0%, 100% { opacity: 1; transform: translateY(-50%) scale(1); }
    50% { opacity: 0.6; transform: translateY(-50%) scale(1.3); }
  }
</style>
<div style="display:flex; align-items:center; gap:8px; padding:10px 12px; background:#1a1a2a; border-left:4px solid #f66; border-radius:4px; margin:6px 0;">
  <div style="font-size:20px;">${icon}</div>
  <div style="flex:1; min-width:0; font-size:13px; font-weight:700; color:#fff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${entityLabel}</div>
  <div style="position:relative;">
    ${indicator('continue')}
    <button onclick="collisionAction('continue','${entityLabel}')" style="min-width:44px; height:44px; background:#1a3a1a; border:2px solid #4a9; color:#4a9; border-radius:6px; font-size:18px; font-weight:700; cursor:pointer;" title="Continue past (risky)">A</button>
  </div>
  <div style="position:relative;">
    ${indicator('reverse')}
    <button onclick="collisionAction('reverse','${entityLabel}')" style="min-width:44px; height:44px; background:#3a1a1a; border:2px solid #f8d66a; color:#f8d66a; border-radius:6px; font-size:18px; font-weight:700; cursor:pointer;" title="Reverse train (avoid)">B</button>
  </div>
  <div style="position:relative;">
    ${indicator('collect')}
    <button onclick="collisionAction('collect','${entityLabel}')" style="min-width:44px; height:44px; background:#2a2a3a; border:2px solid #999; color:#999; border-radius:6px; font-size:18px; font-weight:700; cursor:pointer;" title="Ask to board (probabilistic)">X</button>
  </div>
  <div style="position:relative;">
    ${indicator('delete')}
    <button onclick="collisionAction('delete','${entityLabel}')" style="min-width:44px; height:44px; background:#2a1a1a; border:2px solid #f66; color:#f66; border-radius:6px; font-size:18px; font-weight:700; cursor:pointer;" title="Kill entity (permanent)">Y</button>
  </div>
  <button onclick="viewEntity('${entityLabel}')" style="min-width:44px; height:44px; background:#1a2a2a; border:2px solid #69f; color:#69f; border-radius:6px; font-size:16px; cursor:pointer;" title="Camera focus">üì∑</button>
</div>
      `;
      
      addMessage(channel, 'system', menu, true);
      renderMessages(channel);
      channel.trainPaused = true;
    }
    
    // VIEW ENTITY - Camera focus on specific entity or overview
    window.viewEntity = function(entityLabel) {
      const channel = appState.channels.get(appState.currentChannelId);
      if (!channel || !channel.camera) return;
      
      if (entityLabel === 'overview') {
        // Reset to overview position
        channel.camera.position.set(0, 25, 25);
        channel.camera.lookAt(0, 0, 0);
        addMessage(channel, 'system', `üì∑ Camera reset to **overview**`);
        renderMessages(channel);
        return;
      }
      
      const entities = appState.gridEntities.get(channel.id) || [];
      const entity = entities.find(e => e.label === entityLabel);
      
      if (entity) {
        // Position camera to look at entity
        const entityWorldPos = gridToWorld(entity.row, entity.col);
        channel.camera.position.set(
          entityWorldPos.x,
          8,
          entityWorldPos.z + 10
        );
        channel.camera.lookAt(entityWorldPos.x, 0, entityWorldPos.z);
        
        addMessage(channel, 'system', `üì∑ Camera: **${entityLabel}**`);
        renderMessages(channel);
      }
    };
    
    // ORBITAL DYNAMICS CONTROLS - Minimal and functional
    
    window.cycleOrbitalSpeed = function(direction) {
      const channel = appState.channels.get(appState.currentChannelId);
      if (!channel) return;
      
      if (!channel.orbitalDrift) channel.orbitalDrift = 18;
      channel.orbitalDrift = Math.max(0, Math.min(100, channel.orbitalDrift + (direction * 10)));
      
      const driftEl = document.getElementById('driftValue');
      if (driftEl) driftEl.textContent = channel.orbitalDrift;
      
      // Apply drift to orbital speeds IN REAL TIME
      if (channel.trainCars) {
        channel.trainCars.forEach((body, idx) => {
          const baseDrift = 0.0002 * idx;
          const driftMultiplier = 1 + (channel.orbitalDrift / 100);
          body.orbitSpeed = (0.001 + baseDrift) * driftMultiplier;
        });
      }
      
      addMessage(channel, 'system', `üåå Drift ${direction > 0 ? 'increased' : 'decreased'} to ${channel.orbitalDrift}`);
      renderMessages(channel);
    };
    
    window.resetOrbits = function() {
      const channel = appState.channels.get(appState.currentChannelId);
      if (!channel) return;
      
      channel.trainProgress = 0;
      channel.orbitalDrift = 18;
      channel.trainDirection = 1;
      
      const driftEl = document.getElementById('driftValue');
      if (driftEl) driftEl.textContent = '18';
      
      // Reset all bodies
      if (channel.trainCars) {
        channel.trainCars.forEach((body, idx) => {
          body.orbitSpeed = 0.001 + (0.0002 * idx);
        });
      }
      
      addMessage(channel, 'system', 'üîÑ System reset: drift 18, direction forward, collisions active');
      renderMessages(channel);
    };
    
    // MOON SYSTEM - Add entities as satellites around orbital bodies
    window.addMoonToBody = function() {
      const channel = appState.channels.get(appState.currentChannelId);
      if (!channel || !channel.trainCars || channel.trainCars.length === 0) return;
      
      // Pick a random orbital body to orbit around
      const hostBodyIndex = Math.floor(Math.random() * channel.trainCars.length);
      const hostBody = channel.trainCars[hostBodyIndex];
      const hostName = hostBody.group.userData.bodyName || 'Orbital Body';
      
      // Create moon entity
      const moonTypes = ['üì° Satellite', 'üõ∞Ô∏è Probe', 'üåô Moon', 'üí´ Comet', '‚òÑÔ∏è Asteroid'];
      const moonType = moonTypes[Math.floor(Math.random() * moonTypes.length)];
      const moonName = `${moonType} (${hostName})`;
      
      // Add moon to host body's satellite array
      if (!hostBody.moons) hostBody.moons = [];
      
      const moon = {
        name: moonName,
        angle: Math.random() * Math.PI * 2,
        radius: 2 + Math.random() * 2, // 2-4 units from host
        speed: 0.02 + Math.random() * 0.03, // Orbital speed around host
        size: 0.2 + Math.random() * 0.3,
        color: 0x88aaff
      };
      
      // Create 3D moon mesh
      const moonGeom = new THREE.SphereGeometry(moon.size, 16, 16);
      const moonMat = new THREE.MeshPhongMaterial({
        color: moon.color,
        emissive: moon.color,
        emissiveIntensity: 0.3
      });
      const moonMesh = new THREE.Mesh(moonGeom, moonMat);
      moonMesh.userData.isMoon = true;
      moonMesh.userData.moonName = moonName;
      
      moon.mesh = moonMesh;
      hostBody.moons.push(moon);
      channel.scene.add(moonMesh);
      
      addMessage(channel, 'system', `üåô **${moonName}** added as satellite\n\nü™ê Orbiting: ${hostName}\nüìè Distance: ${moon.radius.toFixed(1)} units\n‚ö° Speed: ${(moon.speed * 100).toFixed(1)}%\n\nüí≠ Moons inherit their host's orbital properties and add complexity to the system.`);
      renderMessages(channel);
      
      TestSuite.log('üåô', 'MOON', `Added ${moonName} to ${hostName}`);
    };
    
    // PHYSICS MODE - N-body gravity simulation
    window.togglePhysics = function() {
      const channel = appState.channels.get(appState.currentChannelId);
      if (!channel) return;
      
      channel.physicsEnabled = !channel.physicsEnabled;
      const btn = document.getElementById('physicsBtn');
      if (btn) {
        btn.textContent = channel.physicsEnabled ? '‚öõÔ∏è Physics: ON' : '‚öõÔ∏è Physics: OFF';
        btn.style.background = channel.physicsEnabled ? '#2a1a3a' : '#1a1a3a';
      }
      
      if (channel.physicsEnabled) {
        // Initialize physics properties for all bodies
        if (!channel.freeEntities) channel.freeEntities = [];
        
        channel.trainCars.forEach((body, idx) => {
          // Assign mass based on size/era (Print is small/fast, AI is large/slow)
          body.mass = 100 + (idx * 50); // Print=100, Radio=150, TV=200, Internet=250, AI=300
          body.gravityField = body.mass * 0.5; // Gravitational influence radius
          
          // Current velocity is its orbital motion
          const angle = (channel.trainProgress + (idx * 0.2)) * Math.PI * 2;
          const radius = body.orbitRadius || 15;
          body.velocity = {
            x: -Math.sin(angle) * body.orbitSpeed * radius,
            z: Math.cos(angle) * body.orbitSpeed * radius
          };
        });
        
        addMessage(channel, 'system', `‚öõÔ∏è **PHYSICS ENABLED**\n\nüåç Bodies now have gravitational fields\nüìä Masses assigned (Print: 100 ‚Üí AI: 300)\nüéØ Release entities to test orbital stability\n\nüí≠ *Watch for tidal effects between bodies*`);
      } else {
        addMessage(channel, 'system', `‚öõÔ∏è **PHYSICS DISABLED**\n\nBodies return to scripted orbits`);
      }
      
      renderMessages(channel);
      TestSuite.log('‚öõÔ∏è', 'PHYSICS', `Physics ${channel.physicsEnabled ? 'ON' : 'OFF'}`);
    };
    
    // RELEASE ENTITY - Drop entity into system and watch physics
    window.releaseEntity = function() {
      const channel = appState.channels.get(appState.currentChannelId);
      if (!channel || !channel.scene) return;
      
      if (!channel.physicsEnabled) {
        addMessage(channel, 'system', '‚ö†Ô∏è Enable physics first (click ‚öõÔ∏è Physics button)');
        renderMessages(channel);
        return;
      }
      
      if (!channel.freeEntities) channel.freeEntities = [];
      
      // Create entity at random position
      const angle = Math.random() * Math.PI * 2;
      const distance = 8 + Math.random() * 20; // 8-28 units from center
      const x = Math.cos(angle) * distance;
      const z = Math.sin(angle) * distance;
      
      // Random initial velocity (perpendicular to radius for potential orbit)
      const speedMagnitude = 0.05 + Math.random() * 0.1;
      const vx = -Math.sin(angle) * speedMagnitude;
      const vz = Math.cos(angle) * speedMagnitude;
      
      const entity = {
        name: `Entity-${channel.freeEntities.length + 1}`,
        mass: 1 + Math.random() * 5, // 1-6 mass
        position: { x, y: 0.5, z },
        velocity: { x: vx, z: vz },
        color: 0x00ff88 + Math.floor(Math.random() * 0x7700), // Bright colors
        size: 0.8 + Math.random() * 0.4, // Larger and more visible
        trail: [] // Store position history for visualization
      };
      
      // Create 3D mesh - MUCH more visible
      const geom = new THREE.SphereGeometry(entity.size, 20, 20);
      const mat = new THREE.MeshPhongMaterial({
        color: entity.color,
        emissive: entity.color,
        emissiveIntensity: 0.8, // Brighter glow
        shininess: 100
      });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.set(x, 0.5, z);
      mesh.userData.isEntity = true;
      mesh.userData.entityName = entity.name;
      
      entity.mesh = mesh;
      channel.scene.add(mesh);
      channel.freeEntities.push(entity);
      
      addMessage(channel, 'system', `üéØ **${entity.name}** released\n\nüìç Position: (${x.toFixed(1)}, ${z.toFixed(1)})\nüèπ Velocity: (${vx.toFixed(3)}, ${vz.toFixed(3)})\n‚öñÔ∏è Mass: ${entity.mass.toFixed(1)}\n\nüîÆ Simulating... will it find stable orbit or crash?`);
      renderMessages(channel);
      
      TestSuite.log('üéØ', 'RELEASE', `Entity ${entity.name} at (${x.toFixed(1)}, ${z.toFixed(1)})`);
    };
    
    function gridToWorld(row, col) {
      const gridSize = 45;
      const cellSize = 5;
      const x = (col - 4) * cellSize;
      const z = (row - 4) * cellSize;
      return { x, z };
    }
    
    // SHOW CAMERA MENU - Entity camera selection
    function showCameraMenu(channel) {
      const entities = appState.gridEntities.get(channel.id) || [];
      
      if (entities.length === 0) {
        addMessage(channel, 'system', 'üì∑ No entities on grid for camera selection');
        renderMessages(channel);
        return;
      }
      
      // Limit to first 8 entities for compact display
      const displayEntities = entities.slice(0, 8);
      
      const cameraButtons = displayEntities.map(e => {
        const icons = { 'Entity': 'üë§', 'Obstacle': '‚õî', 'Solution': '‚úÖ', 'Goal': '‚≠ê', 'Location': 'üìç' };
        const icon = icons[e.type] || '‚ö†';
        return `<button onclick="viewEntity('${e.label}')" style="min-width:44px; height:44px; background:#1a2a2a; border:2px solid #69f; color:#69f; border-radius:6px; font-size:16px; cursor:pointer; display:flex; align-items:center; justify-content:center;" title="${e.label}">${icon}</button>`;
      }).join('');
      
      const menu = `
<div style="display:flex; align-items:center; gap:6px; padding:8px 10px; background:#1a1a2a; border-left:4px solid #69f; border-radius:4px; margin:6px 0; flex-wrap:wrap;">
  <div style="font-size:11px; font-weight:700; color:#69f; min-width:50px;">CAMERAS</div>
  ${cameraButtons}
  <button onclick="viewEntity('overview')" style="min-width:44px; height:44px; background:#1a2a2a; border:2px solid #999; color:#999; border-radius:6px; font-size:14px; cursor:pointer;" title="Overview">‚äô</button>
</div>
      `;
      
      addMessage(channel, 'system', menu, true);
      renderMessages(channel);
    }
    
    // EXECUTE TRACK SWITCH - Direct track switching with AI control
    window.switchTrack = function(track) {
      const channel = appState.channels.get(appState.currentChannelId);
      if (!channel) return;
      
      // Validate track exists
      if (!TRACK_CONFIGS[track]) {
        console.warn('‚ö†Ô∏è Invalid track:', track, '- defaulting to integrate');
        track = 'integrate';
      }
      
      // Update track and train curve - THIS IS THE FIX!
      channel.currentTrack = track;
      const newRadius = TRACK_CONFIGS[track].radius;
      channel.trainCurve = createTrackCurve(newRadius);
      channel.trainPaused = false;
      
      // Hidden prompts for AI scene control
      const hiddenPrompts = {
        main: '[The scene stabilizes. Characters act normally. Maintain current narrative direction.]',
        enhance: '[ENHANCE MODE: Amplify this element. Make it stronger, larger, more intense. Escalate the situation. Add reinforcement.]',
        reverse: '[REVERSE MODE: Diminish this element. Reduce its power, flip its meaning. Create opposition or retreat.]',
        retrieve: '[RETRIEVE MODE: Bring back something from the past. Recall memories, resurrect old elements, restore what was lost.]',
        obsolesce: '[OBSOLESCE MODE: Push this into the background. Make it outdated, irrelevant. Fade it away or replace it.]'
      };
      
      // Inject hidden prompt for AI guidance
      const lastMsg = channel.messages[channel.messages.length - 1];
      if (!lastMsg || lastMsg.text !== hiddenPrompts[track]) {
        channel.messages.push({
          role: 'system',
          text: hiddenPrompts[track],
          hidden: true // Don't display to user
        });
      }
      
      // Rich narrative feedback for track switching
      const narratives = {
        main: `üõ§Ô∏è **MAIN TRACK**\n\nThe train settles onto the original path. Everything stabilizes.\n\n‚ú® *Balance restored. The story proceeds as intended.*\n\nüì° Current mode: MAIN\nüéØ Narrative stance: Neutral observation`,
        
        enhance: `‚ö° Track: ENHANCE`,
        
        reverse: `üîÑ Track: REVERSE`,
        
        retrieve: `‚è™ Track: RETRIEVE`,
        
        obsolesce: `‚¨áÔ∏è Track: OBSOLESCE`
      };
      
      addMessage(channel, 'system', narratives[track]);
      renderMessages(channel);
      
      // SCENE REASSEMBLY - Trigger AI to reshape reality based on tetrad verb
      const reassemblyPrompts = {
        enhance: `The scene reassembles. What grows stronger? What amplifies? What escalates?\n\nAdd 2-3 enhanced versions of existing elements OR amplified obstacles.`,
        reverse: `The scene reverses. What diminishes? What flips meaning? What retreats?\n\nRemove 1-2 entities OR transform them into opposite forms.`,
        retrieve: `The scene retrieves. What returns from the past? What was lost? What memories surface?\n\nAdd 1-2 entities from earlier in the timeline OR restored elements.`,
        obsolesce: `The scene obsolesces. What fades? What becomes outdated? What gets pushed aside?\n\nRemove 1-2 entities OR transform them into obsolete versions.`,
        main: null // Main track = no reassembly
      };
      
      if (reassemblyPrompts[track] && appState.apiKey) {
        // Auto-trigger scene reassembly via AI call
        setTimeout(async () => {
          addMessage(channel, 'system', `üé≠ **SCENE REASSEMBLING**\n\nThe ${track.toUpperCase()} track reshapes reality...`);
          renderMessages(channel);
          
          // Trigger AI to reassemble scene based on tetrad verb
          const reassemblyMessage = `[SCENE REASSEMBLY] Track switched to ${track.toUpperCase()}. ${reassemblyPrompts[track]}`;
          
          // Use existing AI function to process the scene change
          await sendMessageWithLEGOS(channel, reassemblyMessage);
        }, 1500);
      }
      
      // Update train info overlay
      if (channel.dom.trainInfo) {
        channel.dom.trainInfo.innerHTML = 
          `Track: <strong>${TRACK_CONFIGS[track].label}</strong><br>Position: <strong>${Math.round(channel.trainProgress * 100)}%</strong><br>‚ñ∂Ô∏è MOVING`;
      }
      
      // Visual feedback - flash the grid cells (Three.js meshes)
      if (channel.gridCells) {
        channel.gridCells.forEach(cell => {
          if (cell && cell.material) {
            const originalColor = cell.material.color.getHex();
            // TRACK_CONFIGS[track].color is already a hex number (0xff5c7c), not a string
            cell.material.color.setHex(TRACK_CONFIGS[track].color);
            setTimeout(() => {
              cell.material.color.setHex(originalColor);
            }, 300);
          }
        });
      }
      
      // Update 3D track lines color
      if (channel.trackLines) {
        channel.trackLines.forEach(line => {
          if (line.material) {
            line.material.color.setHex(TRACK_CONFIGS[track].color);
          }
        });
      }
      
      TestSuite.log('üöÇ', 'TRACK', `Switched to: ${track} (radius: ${newRadius}), AI prompt injected, visual feedback applied`);
    };
    
    // FORK CHANNEL AT JUNCTION - Create new timeline branch
    window.forkAtJunction = function(track) {
      const parentChannel = appState.channels.get(appState.currentChannelId);
      if (!parentChannel) return;
      
      // Create new channel
      const newChannel = createChannel(`${parentChannel.name} [${track}]`);
      newChannel.parentChannelId = parentChannel.id;
      newChannel.currentTrack = track;
      newChannel.scenario = parentChannel.scenario;
      
      // Clone grid state
      const parentEntities = appState.gridEntities.get(parentChannel.id) || [];
      const clonedEntities = parentEntities.map(e => ({...e}));
      appState.gridEntities.set(newChannel.id, clonedEntities);
      
      // Add fork message
      addMessage(newChannel, 'system', 
        `FORK created from ${parentChannel.name}\\n\\n` +
        `Track: ${track.toUpperCase()}\\n\\n` +
        `This is a new timeline branch.`);
      
      // Render channel (creates DOM)
      renderChannel(newChannel);
      
      // Initialize 3D scene
      init3DForChannel(newChannel);
      
      // Place cloned entities
      clonedEntities.forEach(entity => {
        placeEntityOnGrid(newChannel, entity);
      });
      
      // Focus new channel (tetrad controls only show on collision now)
      appState.currentChannelId = newChannel.id;
      
      TestSuite.log('üîÄ', 'FORK', `Created ${track} fork from ${parentChannel.name}`);
    };
    
    // PAUSE/PLAY TRAIN CONTROL
    window.toggleTrainPause = function() {
      const channel = appState.channels.get(appState.currentChannelId);
      if (!channel) return;
      
      channel.trainPaused = !channel.trainPaused;
      const status = channel.trainPaused ? 'PAUSED' : 'MOVING';
      addMessage(channel, 'system', `${channel.trainPaused ? '‚è∏' : '‚ñ∂Ô∏è'} Train ${status}`);
      renderMessages(channel);
    };
    
    // SHOW TETRAD CONTROLS - Ultra-compact single-line bar
    function showTetradControls(channel) {
      const currentTrack = channel.currentTrack || 'main';
      const controls = `
<div style="display:flex; align-items:center; gap:6px; padding:8px 10px; background:#1a1a2a; border-left:4px solid #69f; border-radius:4px; margin:6px 0;">
  <div style="font-size:11px; font-weight:700; color:#69f; min-width:50px;">${currentTrack.toUpperCase()}</div>
  <button onclick="switchTrack('retrieve')" style="min-width:36px; height:36px; background:#1a1a3a; border:2px solid #69f; color:#69f; border-radius:6px; font-size:16px; cursor:pointer;" title="RETRIEVE">‚Üë</button>
  <button onclick="switchTrack('reverse')" style="min-width:36px; height:36px; background:#3a1a1a; border:2px solid #f66; color:#f66; border-radius:6px; font-size:16px; cursor:pointer;" title="REVERSE">‚Üê</button>
  <button onclick="switchTrack('main')" style="min-width:36px; height:36px; background:#1a1a2a; border:2px solid #69f; color:#69f; border-radius:6px; font-size:16px; cursor:pointer;" title="MAIN">‚óã</button>
  <button onclick="switchTrack('enhance')" style="min-width:36px; height:36px; background:#1a3a1a; border:2px solid #4a9; color:#4a9; border-radius:6px; font-size:16px; cursor:pointer;" title="ENHANCE">‚Üí</button>
  <button onclick="switchTrack('obsolesce')" style="min-width:36px; height:36px; background:#2a2a2a; border:2px solid #999; color:#999; border-radius:6px; font-size:16px; cursor:pointer;" title="OBSOLESCE">‚Üì</button>
  <button onclick="toggleTrainPause()" style="min-width:36px; height:36px; border:2px solid #69f; border-radius:6px; background:#1a1a2a; color:#69f; cursor:pointer; font-size:14px;" title="Pause">‚èØ</button>
</div>
      `;
      
      addMessage(channel, 'system', controls, true);
      renderMessages(channel);
    }
    
    // ANALYZE RESPONSE FOR TRACK SWITCHING - Bayesian inference from LLM
    function analyzeResponseForTrackSwitch(channel, response) {
      const lower = response.toLowerCase();
      
      const trackSignals = {
        enhance: ['enhance', 'improve', 'amplify', 'strengthen', 'grow', 'expand', 'increase', 'better'],
        reverse: ['reverse', 'diminish', 'weaken', 'decline', 'reduce', 'worse', 'backward'],
        retrieve: ['retrieve', 'revive', 'return', 'restore', 'remember', 'past', 'history', 'bring back'],
        obsolesce: ['obsolete', 'outdated', 'replace', 'supercede', 'abandon', 'old', 'ancient']
      };
      
      const scores = {};
      for (const [track, keywords] of Object.entries(trackSignals)) {
        scores[track] = keywords.filter(kw => lower.includes(kw)).length;
      }
      
      const total = Object.values(scores).reduce((sum, val) => sum + val, 0);
      if (total === 0) return null;
      
      const probs = {};
      for (const [track, score] of Object.entries(scores)) {
        probs[track] = score / total;
      }
      
      const maxTrack = Object.keys(probs).reduce((a, b) => 
        probs[a] > probs[b] ? a : b
      );
      
      if (probs[maxTrack] >= 0.4) {
        return {
          track: maxTrack,
          confidence: probs[maxTrack],
          reason: `LLM response indicates ${(probs[maxTrack] * 100).toFixed(0)}% probability for ${maxTrack} track`,
          allProbabilities: probs
        };
      }
      
      return null;
    }
    
    // Global scenario selector
    document.getElementById('globalScenarioSelect').addEventListener('change', (e) => {
      const selection = e.target.value;
      
      // Handle CENTAUR SCENE switching (scene_inner, scene_outer, scene_observer)
      if (selection.startsWith('scene_')) {
        const sceneType = selection.replace('scene_', '').toUpperCase();
        const sceneChannel = Array.from(appState.channels.values()).find(ch => ch.role === sceneType);
        
        if (sceneChannel) {
          // If scene doesn't have DOM yet, render it
          if (!sceneChannel.dom) {
            console.log(`üì∫ Rendering ${sceneType} centaur scene for first time...`);
            renderChannel(sceneChannel);
          }
          
          appState.currentChannelId = sceneChannel.id;
          const columnElement = document.querySelector(`.channel-column[data-channel-id="${sceneChannel.id}"]`);
          if (columnElement) {
            columnElement.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
          }
          TestSuite.log('üëÅÔ∏è', 'SCENE', `Switched to ${sceneType} centaur scene`);
        } else {
          console.warn(`${sceneType} scene not found - centaur mode not initialized`);
        }
        return;
      }
      
      // Handle SCENARIO switching (regular modes)
      const activeChannel = Array.from(appState.channels.values()).find(ch => ch.id === appState.currentChannelId);
      if (activeChannel && SCENARIOS[selection]) {
        activeChannel.scenario = selection;
        addMessage(activeChannel, 'system', `üìã Mode switched to: ${SCENARIOS[selection].name}`);
        renderMessages(activeChannel);
        TestSuite.log('üìã', 'SCENARIO', `Switched to: ${selection}`);
        
        // Auto-trigger unlock progression setup
        if (selection === 'unlock_progression') {
          addMessage(activeChannel, 'system', 'üéÆ UNLOCK PROGRESSION MODE\n\nInitializing crowded training ground...');
          renderMessages(activeChannel);
          
          setTimeout(() => {
            sendMessageWithLEGOS(activeChannel, 'start unlock progression');
          }, 500);
        }
        
        // Auto-trigger Hamlet mode setup
        if (selection === 'hamlet_trolley') {
          addMessage(activeChannel, 'system', '‚è±Ô∏è TIMER: 7 SECONDS\n\nInitializing trolley problem...');
          renderMessages(activeChannel);
          
          setTimeout(() => {
            sendMessageWithLEGOS(activeChannel, 'fill in hamlet mode');
          }, 500);
        }
      }
    });
    
    function renderChannel(channel) {
      const scroller = document.getElementById('channel-scroller');
      const columnDOM = createChannelDOM(channel);
      scroller.appendChild(columnDOM);
      renderMessages(channel);
      attachEventHandlers(channel);
      
      // Initialize 3D scene for this channel (including centaur scenes)
      if (channel.dom && channel.dom.trainCanvas) {
        init3DForChannel(channel);
        TestSuite.log('üé®', TestSuite.stage, `3D scene initialized for ${channel.name}`);
      }
      
      TestSuite.log('‚ú®', TestSuite.stage, `Channel ${channel.name} rendered and active`);
    }
    
    TestSuite.assert(
      'createChannelDOM function defined',
      typeof createChannelDOM === 'function',
      'Creates full DOM structure for channel'
    );
    
    TestSuite.assert(
      'renderMessages function defined',
      typeof renderMessages === 'function',
      'Renders message history to DOM'
    );
    
    TestSuite.assert(
      'attachEventHandlers function defined',
      typeof attachEventHandlers === 'function',
      'Attaches click/keyboard handlers'
    );
    
    TestSuite.stage_summary();
    
    // ========================================
    // STAGE 7: CORNER MENU HANDLERS
    // NOTE: These are defined as functions but NOT executed until DOMContentLoaded
    // ========================================
    
    // Helper to toggle menus (will be used inside DOMContentLoaded)
    function toggleMenu(menuId) {
      const menu = document.getElementById(menuId);
      if (!menu) {
        console.error('Menu not found:', menuId);
        return;
      }
      const alreadyVisible = menu.classList.contains('visible');
      document.querySelectorAll('.corner-menu.visible').forEach(m => m.classList.remove('visible'));
      if (!alreadyVisible) menu.classList.add('visible');
    }
    
    // GLOBAL MOVE CHARACTER FUNCTION - Called by on-screen movement buttons
    window.moveCharacter = function(direction) {
      const channel = appState.channels.get(appState.currentChannelId);
      if (!channel || !channel.avatar) {
        console.warn('No active channel or avatar to move');
        return;
      }
      
      const avatar = channel.avatar;
      let newRow = avatar.row;
      let newCol = avatar.col;
      
      switch(direction) {
        case 'up':
          newRow = Math.max(0, avatar.row - 1);
          break;
        case 'down':
          newRow = Math.min(8, avatar.row + 1);
          break;
        case 'left':
          newCol = Math.max(0, avatar.col - 1);
          break;
        case 'right':
          newCol = Math.min(8, avatar.col + 1);
          break;
        case 'interact':
          // Trigger space bar interaction
          const entities = appState.gridEntities.get(channel.id) || [];
          const nearbyEntity = entities.find(ent => 
            Math.abs(ent.row - avatar.row) <= 1 && Math.abs(ent.col - avatar.col) <= 1
          );
          if (nearbyEntity) {
            addMessage(channel, 'system',
              `ü§ù **Interacting with ${nearbyEntity.label}**\n\n` +
              `Type: ${nearbyEntity.type}\n` +
              `Position: (${nearbyEntity.row}, ${nearbyEntity.col})\n\n` +
              `(Negotiation system coming soon...)`
            );
          } else {
            addMessage(channel, 'system', '‚ùå No entity nearby. Move closer and press ‚ö° to interact.');
          }
          renderMessages(channel);
          return;
      }
      
      // Move if position changed
      if (newRow !== avatar.row || newCol !== avatar.col) {
        avatar.row = newRow;
        avatar.col = newCol;
        
        const pos = gridRowColToWorld(newRow, newCol);
        avatar.mesh.position.x = pos.x;
        avatar.mesh.position.z = pos.z;
        
        // Update psychograph
        if (window.schedulePsychographUpdate) {
          window.schedulePsychographUpdate(channel);
        }
        
        // Check for nearby entities
        const entities = appState.gridEntities.get(channel.id) || [];
        const nearbyEntity = entities.find(ent => 
          Math.abs(ent.row - newRow) <= 1 && Math.abs(ent.col - newCol) <= 1
        );
        
        if (nearbyEntity) {
          addMessage(channel, 'system',
            `üö∂ Moved to (${newRow}, ${newCol})\n\n` +
            `üìç **${nearbyEntity.label}** is here!\nClick ‚ö° to interact.`
          );
        } else {
          addMessage(channel, 'system', `üö∂ Moved to (${newRow}, ${newCol})`);
        }
        renderMessages(channel);
      }
    };
    
    // Function to bind all global button handlers (will be called in DOMContentLoaded)
    function bindGlobalControls() {
      TestSuite.stage = 'STAGE-7-MENU';
      TestSuite.log('üéõÔ∏è', TestSuite.stage, 'Binding global control handlers...');
      
      // Close menus when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.corner-btn') && !e.target.closest('.corner-menu')) {
          document.querySelectorAll('.corner-menu.visible').forEach(m => m.classList.remove('visible'));
        }
      });
      
      // API Key Button (Top Left)
      const cornerKey = document.getElementById('cornerKey');
      if (cornerKey) {
        cornerKey.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleMenu('keyMenu');
        });
        TestSuite.log('‚úÖ', TestSuite.stage, 'Corner Key button bound');
      } else {
        TestSuite.log('‚ùå', TestSuite.stage, 'Corner Key button NOT FOUND');
      }
    
      // Help Button (Top Right)
      const cornerHelp = document.getElementById('cornerHelp');
      if (cornerHelp) {
        cornerHelp.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleMenu('helpMenu');
        });
        TestSuite.log('‚úÖ', TestSuite.stage, 'Corner Help button bound');
      } else {
        TestSuite.log('‚ùå', TestSuite.stage, 'Corner Help button NOT FOUND');
      }
      
      // Import/Export Button (Bottom Left)
      const cornerExchange = document.getElementById('cornerExchange');
      if (cornerExchange) {
        cornerExchange.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleMenu('exchangeMenu');
        });
        TestSuite.log('‚úÖ', TestSuite.stage, 'Corner Exchange button bound');
      } else {
        TestSuite.log('‚ùå', TestSuite.stage, 'Corner Exchange button NOT FOUND');
      }
      
      // Add Channel Button (Bottom Right)
      const cornerAdd = document.getElementById('cornerAdd');
      if (cornerAdd) {
        cornerAdd.addEventListener('click', () => {
          TestSuite.log('‚ûï', TestSuite.stage, 'Add channel clicked');
          const parentChannel = appState.channels.get(appState.currentChannelId);
          const newChannel = createChannel();
          appState.currentChannelId = newChannel.id;

          if (parentChannel) {
            newChannel.parentChannelId = parentChannel.id;
            addMessage(newChannel, 'system', `üîÄ Forked from ${parentChannel.name}.`);
          } else {
            addMessage(newChannel, 'system', 'üÜï New channel ready.');
          }

          renderChannel(newChannel);
          init3DForChannel(newChannel);
        });
        TestSuite.log('‚úÖ', TestSuite.stage, 'Corner Add button bound');
      } else {
        TestSuite.log('‚ùå', TestSuite.stage, 'Corner Add button NOT FOUND');
      }
      
      // Key Menu Actions
      document.querySelectorAll('#keyMenu button').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const action = btn.dataset.action;
          if (action === 'set-key') {
            const key = prompt('Enter OpenAI API Key:', appState.apiKey || '');
            if (key) {
              appState.apiKey = key;
              localStorage.setItem('openai_api_key', key);
              alert('‚úÖ API Key saved!');
            }
          } else if (action === 'clear-key') {
            if (confirm('Clear saved API key?')) {
              appState.apiKey = null;
              localStorage.removeItem('openai_api_key');
              alert('‚úÖ Key cleared.');
            }
          } else if (action === 'test-key') {
            if (!appState.apiKey) {
              alert('‚ùå No API key set.');
            } else {
              alert('‚úÖ API key is set.\n\n' + appState.apiKey.substring(0, 10) + '...');
            }
          }
          toggleMenu('keyMenu');
        });
      });
      
      // Help Menu Actions
      document.querySelectorAll('#helpMenu button').forEach(btn => {
        btn.addEventListener('click', () => {
          const action = btn.dataset.action;
          if (action === 'tour') {
            alert('üé¨ TOUR\n\n1. Set API key (‚óé)\n2. Create channel (Ôºã)\n3. Type message\n4. Watch train move\n5. Choose tetrad track at junction');
          } else if (action === 'hints') {
            alert('üí° HINTS\n\n‚Ä¢ Grid cells light up as train passes\n‚Ä¢ Gold cone = Goal\n‚Ä¢ Red cone = Obstacle\n‚Ä¢ Green cone = Entity/Solution\n‚Ä¢ Pause = Junction decision point');
          } else if (action === 'reset-camera') {
            if (appState.currentChannelId) {
              const channel = appState.channels.get(appState.currentChannelId);
              if (channel && channel.camera) {
                channel.camera.position.set(0, 15, 15);
                channel.camera.lookAt(0, 0, 0);
                addMessage(channel, 'system', 'üé• Camera reset to overview');
                renderMessages(channel);
                TestSuite.log('üé•', 'CAMERA', 'Camera reset to overview');
              }
            }
          } else if (action === 'help') {
            alert('üöÇ RAILWAY JUNCTION\n\n‚óé API Key - Manage OpenAI key\n? Help - This menu\n‚áÜ Import/Export - Save/load\nÔºã New Channel - Add conversation\n\nTetrad tracks:\n‚Ä¢ Enhance (green)\n‚Ä¢ Reverse (red)\n‚Ä¢ Retrieve (blue)\n‚Ä¢ Obsolesce (gray)');
          } else if (action === 'about') {
            alert('üöÇ Railway Junction v1.0\n\nA spatial narrative system combining:\n‚Ä¢ 3D train visualization\n‚Ä¢ LEGOS entity framework\n‚Ä¢ McLuhan tetrad decision points\n\nBuilt with Three.js, Tone.js');
          } else if (action === 'reset') {
            if (confirm('‚ö†Ô∏è Reset all channels and data?\n\nThis cannot be undone.')) {
              appState.channels.clear();
              appState.gridEntities.clear();
              document.getElementById('channel-scroller').innerHTML = '';
              alert('‚úÖ All data cleared.');
            }
          }
          toggleMenu('helpMenu');
        });
      });
      
      // Exchange Menu Actions
      document.querySelectorAll('#exchangeMenu button').forEach(btn => {
        btn.addEventListener('click', () => {
          const action = btn.dataset.action;
          if (action === 'export' || action === 'export-json') {
            const data = {
              channels: Array.from(appState.channels.values()).map(ch => ({
                id: ch.id,
                name: ch.name,
                messages: ch.messages,
                entities: ch.entities,
                currentTrack: ch.currentTrack
              })),
              gridEntities: Array.from(appState.gridEntities.entries()),
              timestamp: Date.now()
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `railway-junction-${Date.now()}.json`;
            a.click();
            alert('‚úÖ Data exported!');
          } else if (action === 'import') {
            document.getElementById('importInput').click();
          }
          toggleMenu('exchangeMenu');
        });
      });
      
      // Import handler
      document.getElementById('importInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);
            alert('‚úÖ Data imported!\n\n' + data.channels.length + ' channels loaded.');
          } catch (err) {
            alert('‚ùå Import failed: ' + err.message);
          }
        };
        reader.readAsText(file);
      });
      
      // Verify all buttons exist
      TestSuite.assert(
        'API Key button (cornerKey) exists',
        document.getElementById('cornerKey') !== null,
        'Top-left corner button'
      );
      
      TestSuite.assert(
        'Help button (cornerHelp) exists',
        document.getElementById('cornerHelp') !== null,
        'Top-right corner button'
      );
      
      TestSuite.assert(
        'Import/Export button (cornerExchange) exists',
        document.getElementById('cornerExchange') !== null,
        'Bottom-left corner button'
      );
      
      TestSuite.assert(
        'Add Channel button (cornerAdd) exists',
        document.getElementById('cornerAdd') !== null,
        'Bottom-right corner button'
      );
      
      // Global Scenario Selector - REMOVED: Duplicate listener
      // The main scenario selector handler is at line ~5307
      // This was causing double-firing and trying to render uninitialized centaur scenes
      TestSuite.log('‚úÖ', TestSuite.stage, 'Global scenario selector bound (primary handler at line 5307)');
      
      // TETRAD BUTTON - Open perspective overlay (existing functionality)
      const globalTetradBtn = document.getElementById('globalTetradBtn');
      if (globalTetradBtn) {
        globalTetradBtn.addEventListener('click', () => {
          if (appState.currentChannelId) {
            const channel = appState.channels.get(appState.currentChannelId);
            if (channel) {
              openPerspectiveSelector(channel);
            }
          }
        });
        TestSuite.log('‚úÖ', TestSuite.stage, 'Tetrad button bound');
      }
      
      TestSuite.stage_summary();
      TestSuite.log('‚úÖ', TestSuite.stage, 'All global controls bound successfully');
    } // END bindGlobalControls()
    
    // OPEN PERSPECTIVE SELECTOR - Show all entities with FORK and DELETE buttons
    function openPerspectiveSelector(channel) {
      const entities = appState.gridEntities.get(channel.id) || [];
      const overlay = document.getElementById('perspectiveOverlay');
      const content = document.getElementById('perspectiveContent');
      
      if (entities.length === 0) {
        content.innerHTML = '<p style="color:var(--text-muted); text-align:center; padding:24px;">No entities on grid. Add some via chat!</p>';
      } else {
        content.innerHTML = `
          <h2 style="color:var(--accent); margin:0 0 16px 0; font-size:16px; letter-spacing:0.1em;">ENTITY PERSPECTIVES</h2>
          <p style="color:var(--text-muted); font-size:12px; margin-bottom:16px;">Fork from entity POV or delete entities.</p>
          <div style="display:flex; flex-direction:column; gap:10px;">
            ${entities.map(e => `
              <div style="
                display:flex; 
                justify-content:space-between; 
                align-items:center;
                background:var(--panel-dark); 
                border:1px solid var(--border); 
                padding:12px; 
                border-radius:4px;
                transition:all 0.2s;
              " onmouseover="this.style.borderColor='var(--accent)';" onmouseout="this.style.borderColor='var(--border)';">
                <div style="flex:1;">
                  <div style="color:var(--text); font-weight:600;"><strong>${e.type}:</strong> ${e.label}</div>
                  <div style="color:var(--text-muted); font-size:11px; margin-top:4px;">Position: (${e.row},${e.col})</div>
                </div>
                <div style="display:flex; gap:8px;">
                  <button onclick="forkFromEntityPerspective('${channel.id}', '${e.label.replace(/'/g, "\\'")}')" style="
                    padding:8px 14px; 
                    background:var(--accent); 
                    color:white; 
                    border:none; 
                    border-radius:4px; 
                    cursor:pointer; 
                    font-size:11px; 
                    font-weight:600;
                    transition:all 0.2s;
                  " onmouseover="this.style.background='var(--accent-bright)';" onmouseout="this.style.background='var(--accent)';">
                    FORK POV
                  </button>
                  <button onclick="chatWithEntity('${channel.id}', '${e.label.replace(/'/g, "\\'")}')" style="
                    padding:8px 14px; 
                    background:#5c7cff; 
                    color:white; 
                    border:none; 
                    border-radius:4px; 
                    cursor:pointer; 
                    font-size:11px; 
                    font-weight:600;
                    transition:all 0.2s;
                  " onmouseover="this.style.background='#7c9cff';" onmouseout="this.style.background='#5c7cff';">
                    CHAT
                  </button>
                  <button onclick="deleteEntityFromPanel('${channel.id}', '${e.label.replace(/'/g, "\\'")}')" style="
                    padding:8px 14px; 
                    background:#ff4444; 
                    color:white; 
                    border:none; 
                    border-radius:4px; 
                    cursor:pointer; 
                    font-size:11px; 
                    font-weight:600;
                    transition:all 0.2s;
                  " onmouseover="this.style.background='#ff6666';" onmouseout="this.style.background='#ff4444';">
                    DELETE
                  </button>
                </div>
              </div>
            `).join('')}
          </div>
        `;
      }
      
      overlay.style.display = 'flex';
      
      // Close handler
      const closeBtn = overlay.querySelector('.close-overlay');
      closeBtn.onclick = () => {
        overlay.style.display = 'none';
      };
      
      TestSuite.log('‚ú¶', 'TETRAD', `Opened perspective selector (${entities.length} entities)`);
    }
    
    // FORK FROM ENTITY PERSPECTIVE - Create new channel from entity's POV
    function forkFromEntityPerspective(channelId, entityLabel) {
      const channel = appState.channels.get(channelId);
      if (!channel) return;
      
      const entities = appState.gridEntities.get(channel.id) || [];
      const entity = entities.find(e => e.label === entityLabel);
      if (!entity) {
        alert(`Entity "${entityLabel}" not found.`);
        return;
      }
      
      // Close overlay
      const overlay = document.getElementById('perspectiveOverlay');
      overlay.style.display = 'none';
      
      // Create fork with entity perspective
      const forkName = `${entityLabel} POV`;
      const forkInstruction = `${SCENARIOS[channel.scenario].systemInstruction}\n\nüé≠ PERSPECTIVE LOCK: You are ${entityLabel}, a ${entity.type} at grid position (${entity.row},${entity.col}).\n\nYou MUST respond as ${entityLabel} in first person. Describe what you see, feel, and think from this position. Reference nearby entities and the unfolding situation.\n\nWhen user asks questions, answer as ${entityLabel} would - with their fears, hopes, and limited knowledge.`;
      
      const newChannel = createChannel(forkName, channel.scenario, forkInstruction);
      
      // Clone grid state from parent
      const parentEntities = appState.gridEntities.get(channel.id) || [];
      appState.gridEntities.set(newChannel.id, parentEntities.map(e => ({...e})));
      
      // Mark this channel as a fork
      newChannel.parentChannelId = channel.id;
      newChannel.forkPoint = { type: 'entity_perspective', entity: entityLabel, position: { row: entity.row, col: entity.col } };
      
      addMessage(newChannel, 'system', `üîÄ Forked from ${channel.name}\n‚ú¶ Perspective: ${entityLabel}\nüìç Position: (${entity.row},${entity.col})\n\nYou are now experiencing the scene as ${entityLabel}. All responses will be in their voice.`);
      
      // Render the new channel (creates DOM + renders messages)
      renderChannel(newChannel);
      
      // Initialize 3D scene for the forked channel
      init3DForChannel(newChannel);
      
      // Now place entities in 3D scene (after init3D creates gridCells)
      parentEntities.forEach(e => {
        placeEntityOnGrid(newChannel, e);
      });
      
      // Set as current channel
      appState.currentChannelId = newChannel.id;
      
      TestSuite.log('üîÄ', 'FORK', `Created entity perspective fork: ${entityLabel}`);
    }
    
    // DELETE ENTITY FROM PANEL - Remove entity with notification
    function deleteEntityFromPanel(channelId, entityLabel) {
      const channel = appState.channels.get(channelId);
      if (!channel) return;
      
      if (!confirm(`Delete "${entityLabel}" from the grid?`)) return;
      
      const removed = removeEntityFromGrid(channel, { target: entityLabel });
      
      if (removed) {
        addMessage(channel, 'system', `üóëÔ∏è Deleted: ${entityLabel}`);
        renderMessages(channel);
        
        // Refresh perspective panel
        openPerspectiveSelector(channel);
        
        TestSuite.log('üóëÔ∏è', 'DELETE', `Removed ${entityLabel} from panel`);
      } else {
        alert(`Failed to delete "${entityLabel}".`);
      }
    }
    
    // CHAT WITH ENTITY - Shows as thought bubbles, NO scene updates
    function chatWithEntity(channelId, entityLabel) {
      const channel = appState.channels.get(channelId);
      if (!channel) return;
      
      const overlay = document.getElementById('perspectiveOverlay');
      overlay.style.display = 'none';
      
      // Set flag to prevent scene updates
      channel.chatModeOnly = true;
      
      channel.dom.input.value = `@${entityLabel} `;
      channel.dom.input.focus();
      
      addMessage(channel, 'system', `üí≠ Chat mode: ${entityLabel}\n\nEntity will respond as thought bubbles. Scene will NOT update.\nType "exit chat" to resume normal mode.`);
      renderMessages(channel);
      
      TestSuite.log('üí≠', 'CHAT', `Chat mode activated for ${entityLabel}`);
    }
    
    // VIEW ENTITY PERSPECTIVE - Legacy function for backwards compatibility
    function viewEntityPerspective(channelId, entityLabel) {
      // Just set @mention for now
      const channel = appState.channels.get(channelId);
      if (!channel) return;
      
      const overlay = document.getElementById('perspectiveOverlay');
      overlay.style.display = 'none';
      
      channel.dom.input.value = `@${entityLabel} `;
      channel.dom.input.focus();
      
      addMessage(channel, 'system', `‚ú¶ Now chatting with: ${entityLabel}\n\nType your message to talk to this entity.`);
      renderMessages(channel);
    }
    
    // ========================================
    // STAGE 8: RENDER INITIAL CHANNEL
    // ========================================
    
    // STAGE 8 will run after DOM ready - defined below
    
    // ========================================
    // STAGE 9: 3D TRAIN RENDERING
    // ========================================
    
    // STAGE 9 functions - will be called after DOM ready
    
    // ========================================
    // TRAINING GROUND DATA (from tra.html)
    // ========================================
    
    const TRAINING_GROUND = {
      AXES: ['IDENTITY', 'EXPERIENCE', 'LANGUAGE', 'DOMAIN', 'PURPOSE', 'ORDER'],
      STAGES: ['SHED', 'INTEGRATE', 'GROUND'],
      
      // Scene-specific axis labels
      INNER_LABELS: {
        'IDENTITY': 'Instinct',
        'EXPERIENCE': 'Seen',
        'LANGUAGE': 'Ideas',
        'DOMAIN': 'Source',
        'PURPOSE': 'Heart',
        'ORDER': 'Parts'
      },
      OUTER_LABELS: {
        'IDENTITY': 'Reason',
        'EXPERIENCE': 'Unseen',
        'LANGUAGE': 'Ideology',
        'DOMAIN': 'Resource',
        'PURPOSE': 'Head',
        'ORDER': 'Whole'
      },
      
      FLOW: {
        SHED: {
          IDENTITY: {
            INNER: { text: 'Eliminate Current Emotional Noise', target: 'Noise In Immediate Preference', pair: 'Instinct', color: 0xff5c7c },
            OUTER: { text: 'Decomission Current Unused Formalisms', target: 'Current Structural Excess', pair: 'Reason', color: 0xff7c9c }
          },
          EXPERIENCE: {
            INNER: { text: 'Reduce Current Sensory Noise', target: 'Ephemeral Phenomena', pair: 'Seen', color: 0xff5c7c },
            OUTER: { text: 'Reject Hidden Redundancy', target: 'Non-Essential Inferences', pair: 'Unseen', color: 0xff7c9c }
          },
          LANGUAGE: {
            INNER: { text: 'Sharpen Units Of Current Meaning', target: 'Unnecessary Ideas', pair: 'Ideas', color: 0xff5c7c },
            OUTER: { text: 'Dismantle Current Group Ideology', target: 'Obsolete Guiding System', pair: 'Ideology', color: 0xff7c9c }
          },
          DOMAIN: {
            INNER: { text: 'Cultivate New Origin Points', target: 'Current Source Dependence', pair: 'Source', color: 0xff5c7c },
            OUTER: { text: 'Discard Unnecessary Action Assets', target: 'Current Inventory Excess', pair: 'Resource', color: 0xff7c9c }
          },
          PURPOSE: {
            INNER: { text: 'Purify Current Emotional Drive', target: 'Emotional Drive', pair: 'Heart', color: 0xff5c7c },
            OUTER: { text: 'De-Clutter Current Strategic Noise', target: 'Strategic Noise', pair: 'Head', color: 0xff7c9c }
          },
          ORDER: {
            INNER: { text: 'Isolate Redundant Current Parts', target: 'Individual Components', pair: 'Parts', color: 0xff5c7c },
            OUTER: { text: 'Restructure Current Systemic Arrangement', target: 'Obsolete Structure', pair: 'Whole', color: 0xff7c9c }
          }
        },
        INTEGRATE: {
          IDENTITY: {
            INNER: { text: 'Align Instinct to Conscious Goals', target: 'Directional Clarity', pair: 'Instinct', color: 0x569fff },
            OUTER: { text: 'Link Reason to External Feedback', target: 'Environmental Input', pair: 'Reason', color: 0x76afff }
          },
          EXPERIENCE: {
            INNER: { text: 'Map Seen to Underlying Structure', target: 'Unseen Dynamics', pair: 'Seen', color: 0x569fff },
            OUTER: { text: 'Verify Unseen to Current Seen Phenomena', target: 'Real-Time Evidence', pair: 'Unseen', color: 0x76afff }
          },
          LANGUAGE: {
            INNER: { text: 'Synthesize Ideas to Coherent Patterns', target: 'Systematic Meaning', pair: 'Ideas', color: 0x569fff },
            OUTER: { text: 'Connect New Ideas to Guiding Narrative', target: 'System Cohesion', pair: 'Ideology', color: 0x76afff }
          },
          DOMAIN: {
            INNER: { text: 'Establish Source to Resource Flow', target: 'Usable Assets', pair: 'Source', color: 0x569fff },
            OUTER: { text: 'Optimize Resource to Goal Vector', target: 'Purposeful Action', pair: 'Resource', color: 0x76afff }
          },
          PURPOSE: {
            INNER: { text: 'Harmonize Heart to Head Clarity', target: 'Cognitive System', pair: 'Heart', color: 0x569fff },
            OUTER: { text: 'Adjust Head to Heart Direction', target: 'Emotional Alignment', pair: 'Head', color: 0x76afff }
          },
          ORDER: {
            INNER: { text: 'Combine Parts to Coherent Whole', target: 'System Assembly', pair: 'Parts', color: 0x569fff },
            OUTER: { text: 'Integrate Whole to New Patterns', target: 'Constituent Parts', pair: 'Whole', color: 0x76afff }
          }
        },
        GROUND: {
          IDENTITY: {
            INNER: { text: 'Commit Core Value to Present Action', target: 'Stable Instinct', pair: 'Instinct', color: 0x56ff9f },
            OUTER: { text: 'Formalize Principle Into Present Use', target: 'Structural Logic', pair: 'Reason', color: 0x76ffaf }
          },
          EXPERIENCE: {
            INNER: { text: 'Apply Observation Protocol to Present', target: 'Current Senses', pair: 'Seen', color: 0x56ff9f },
            OUTER: { text: 'Standardize Inference Method', target: 'Stable Inference', pair: 'Unseen', color: 0x76ffaf }
          },
          LANGUAGE: {
            INNER: { text: 'Document Concept For Present Use', target: 'Fixed Vocabulary', pair: 'Ideas', color: 0x56ff9f },
            OUTER: { text: 'Formalize Narrative Into Shared Beliefs', target: 'Current Shared Beliefs', pair: 'Ideology', color: 0x76ffaf }
          },
          DOMAIN: {
            INNER: { text: 'Sustain Source For Present Use', target: 'Perpetual Origin', pair: 'Source', color: 0x56ff9f },
            OUTER: { text: 'Secure Asset Base For Present', target: 'Fixed Assets', pair: 'Resource', color: 0x76ffaf }
          },
          PURPOSE: {
            INNER: { text: 'Execute Chosen Goal With Full Commit', target: 'Affective Center', pair: 'Heart', color: 0x56ff9f },
            OUTER: { text: 'Implement Strategy Into Formal Plan', target: 'Cognitive Plan', pair: 'Head', color: 0x76ffaf }
          },
          ORDER: {
            INNER: { text: 'Stabilize Arrangement Into Fixed State', target: 'Fixed Components', pair: 'Parts', color: 0x56ff9f },
            OUTER: { text: 'Institutionalize Order Into Function', target: 'Functioning System', pair: 'Whole', color: 0x76ffaf }
          }
        }
      }
    };
    
    // 3D Radar is now created as part of the scene geometry (see init3DForChannel)
    // The update3DRadar function is stored on the channel object
    
    function init3DForChannel(channel) {
      console.log('\n=== üé® INITIALIZING 3D SCENE FOR CHANNEL:', channel.id, '===\n');
      
      const canvas = channel.dom.trainCanvas;
      if (!canvas) {
        TestSuite.log('‚ö†Ô∏è', TestSuite.stage, 'No canvas found for channel');
        console.error('‚ùå Canvas missing - 3D initialization aborted');
        return;
      }
      
      console.log('‚úÖ Canvas found:', canvas.width + 'x' + canvas.height);
      
      // Scene
      TestSuite.log('üåå', TestSuite.stage, 'Creating Three.js scene...');
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);
      scene.fog = new THREE.Fog(0x1a1a1a, 30, 100);
      console.log('‚úÖ Scene created with fog and background');
      
      // Camera - WIDE VIEW to see whole circle
      const camera = new THREE.PerspectiveCamera(
        50,
        canvas.width / canvas.height,
        0.1,
        500
      );
      camera.position.set(35, 40, 35); // High angle to see full grid
      
      // Renderer
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(canvas.width, canvas.height);
      renderer.shadowMap.enabled = true;
      
      // Controls - Target center of grid
      const controls = new THREE.OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.target.set(0, 0, 0); // Look at grid center
      controls.minDistance = 30;
      controls.maxDistance = 80;
      
      // Lights
      scene.add(new THREE.AmbientLight(0x404040, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(50, 50, 50);
      dirLight.castShadow = true;
      scene.add(dirLight);
      
      // GRID FLOOR - 9x9 grid as the ground
      const gridSize = 45; // Grid spans 45m
      const cellSize = gridSize / 9;
      const gridGroup = new THREE.Group();
      
      // Create 81 grid cells as 3D planes
      channel.gridCells = [];
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          const cellGeometry = new THREE.PlaneGeometry(cellSize * 0.95, cellSize * 0.95);
          const cellMaterial = new THREE.MeshLambertMaterial({
            color: 0x0f766e,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide
          });
          const cellMesh = new THREE.Mesh(cellGeometry, cellMaterial);
          
          // Position: center grid at origin
          const x = (col - 4) * cellSize;
          const z = (row - 4) * cellSize;
          cellMesh.position.set(x, 0.01, z);
          cellMesh.rotation.x = -Math.PI / 2;
          cellMesh.receiveShadow = true;
          
          // Add userData for click detection and hexagon updates
          cellMesh.userData.gridCell = true;
          cellMesh.userData.row = row;
          cellMesh.userData.col = col;
          
          // Add border
          const edges = new THREE.EdgesGeometry(cellGeometry);
          const line = new THREE.LineSegments(edges, 
            new THREE.LineBasicMaterial({ color: 0x60a5fa, transparent: true, opacity: 0.3 }));
          line.rotation.x = -Math.PI / 2;
          line.position.copy(cellMesh.position);
          
          gridGroup.add(cellMesh);
          gridGroup.add(line);
          channel.gridCells.push({ mesh: cellMesh, row, col, material: cellMaterial });
        }
      }
      scene.add(gridGroup);
      console.log('‚úÖ Grid created: 81 cells (9x9), cell size:', cellSize);
      
      // Dark base ground under grid
      const baseGround = new THREE.Mesh(
        new THREE.PlaneGeometry(80, 80),
        new THREE.MeshLambertMaterial({ color: 0x1a1a1a })
      );
      baseGround.rotation.x = -Math.PI / 2;
      baseGround.position.y = -0.1;
      baseGround.receiveShadow = true;
      scene.add(baseGround);
      
      TestSuite.log('üéØ', TestSuite.stage, 'Grid floor created: 9√ó9 cells in 3D scene');
      
      // Create 3 rings (SHED/INTEGRATE/GROUND)
      TestSuite.log('‚≠ï', TestSuite.stage, 'Creating operation rings...');
      console.log('Ring configurations:', Object.keys(TRACK_CONFIGS));
      Object.entries(TRACK_CONFIGS).forEach(([trackId, config]) => {
        console.log(`  Creating ${config.label} ring: radius ${config.radius}, color #${config.color.toString(16)}`);
        const curve = createTrackCurve(config.radius);
        const points = curve.getPoints(100);
        const geometry = new THREE.BufferGeometry().setFromPoints(
          points.map(p => new THREE.Vector3(p.x, 0.2, p.y))
        );
        const material = new THREE.LineBasicMaterial({
          color: config.color,
          linewidth: 2,
          transparent: true,
          opacity: 0.6
        });
        const line = new THREE.Line(geometry, material);
        scene.add(line);
      });
      
      // CREATE 3D RADAR GEOMETRY (like orbital rings but for training axes)
      channel.radarLines = [];
      channel.radarPolygon = null;
      
      function update3DRadar() {
        // Remove old radar geometry
        channel.radarLines.forEach(line => scene.remove(line));
        if (channel.radarPolygon) scene.remove(channel.radarPolygon);
        channel.radarLines = [];
        
        const axisValues = channel.trainingAxisValues || TRAINING_GROUND.AXES.map(() => 0.3);
        const angleStep = (Math.PI * 2) / TRAINING_GROUND.AXES.length;
        const maxRadius = 35; // Larger than outermost orbital ring
        
        // Draw axis lines from center
        TRAINING_GROUND.AXES.forEach((axis, i) => {
          const angle = i * angleStep - Math.PI / 2;
          const radius = maxRadius;
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          
          const geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0.05, 0),
            new THREE.Vector3(x, 0.05, z)
          ]);
          
          const material = new THREE.LineBasicMaterial({
            color: 0xff4d2e,
            transparent: true,
            opacity: 0.2,
            linewidth: 1
          });
          
          const line = new THREE.Line(geometry, material);
          scene.add(line);
          channel.radarLines.push(line);
          
          // Axis labels removed - now only in chat and header
        });
        
        // Draw polygon connecting axis values
        const polygonPoints = [];
        axisValues.forEach((val, i) => {
          const angle = i * angleStep - Math.PI / 2;
          const r = val * maxRadius;
          polygonPoints.push(new THREE.Vector3(
            Math.cos(angle) * r,
            0.1,
            Math.sin(angle) * r
          ));
        });
        polygonPoints.push(polygonPoints[0]); // Close the loop
        
        // Radar outline
        const outlineGeometry = new THREE.BufferGeometry().setFromPoints(polygonPoints);
        const outlineMaterial = new THREE.LineBasicMaterial({
          color: 0xff4d2e,
          transparent: true,
          opacity: 0.8,
          linewidth: 3
        });
        const outline = new THREE.Line(outlineGeometry, outlineMaterial);
        scene.add(outline);
        channel.radarPolygon = outline;
        
        // Filled polygon (using shape)
        const shape = new THREE.Shape();
        polygonPoints.forEach((point, i) => {
          if (i === 0) shape.moveTo(point.x, point.z);
          else shape.lineTo(point.x, point.z);
        });
        
        const fillGeometry = new THREE.ShapeGeometry(shape);
        const fillMaterial = new THREE.MeshBasicMaterial({
          color: 0xff4d2e,
          transparent: true,
          opacity: 0.15,
          side: THREE.DoubleSide
        });
        const fill = new THREE.Mesh(fillGeometry, fillMaterial);
        fill.rotation.x = -Math.PI / 2;
        fill.position.y = 0.08;
        scene.add(fill);
        channel.radarLines.push(fill);
      }
      
      // Store update function
      channel.update3DRadar = update3DRadar;
      
      // Initial draw
      TestSuite.log('üìä', TestSuite.stage, 'Creating 6-axis psychographic radar...');
      console.log('Radar axes:', TRAINING_GROUND.AXES);
      update3DRadar();
      console.log('‚úÖ Radar created with hexagonal polygon and axis lines');
      
      TestSuite.log('üìä', TestSuite.stage, '3D Psychographic radar created on grid plane');
      
      // Create central star with scene-specific glow
      const centralStar = createCentralStar(channel.sceneType);
      centralStar.position.set(0, 1, 0);
      scene.add(centralStar);
      channel.centralStar = centralStar; // Store reference
      
      // RADAR SCANNING LINES: 6 rays (one per axis) sweeping outward from center
      const radarLines = [];
      const radarColors = [0xff5c7c, 0xff7c9c, 0x569fff, 0x76afff, 0x56ff9f, 0x76ffaf];
      
      TestSuite.log('üì°', TestSuite.stage, 'Creating radar scanning rays...');
      console.log('Radar axes:', TRAINING_GROUND.AXES);
      
      TRAINING_GROUND.AXES.forEach((axis, idx) => {
        const angle = (idx / TRAINING_GROUND.AXES.length) * Math.PI * 2;
        const color = radarColors[idx];
        
        // Create line geometry
        const lineGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array([
          0, 0.1, 0,  // Start at center
          0, 0.1, 0   // End (will be updated in animation)
        ]);
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const lineMaterial = new THREE.LineBasicMaterial({
          color: color,
          linewidth: 2,
          transparent: true,
          opacity: 0.8
        });
        
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);
        
        radarLines.push({
          line: line,
          axis: axis,
          angle: angle,
          color: color,
          phase: idx * 0.5  // Stagger start times
        });
        
        console.log(`  Created ${axis} ray: angle ${(angle * 180 / Math.PI).toFixed(0)}¬∞, color #${color.toString(16)}`);
      });
      
      channel.radarLines = radarLines;
      
      // CREATE AVATAR (player character) - ENHANCED with glow + eye label
      TestSuite.log('üéÆ', TestSuite.stage, 'Creating player avatar...');
      
      // Main cone body with STRONGER glow
      const avatarGeometry = new THREE.ConeGeometry(0.5, 1.5, 4);
      const avatarMaterial = new THREE.MeshStandardMaterial({
        color: 0xff4d2e,
        emissive: 0xff4d2e,
        emissiveIntensity: 1.2, // INCREASED from 0.5 to 1.2
        metalness: 0.3,
        roughness: 0.7
      });
      const avatarMesh = new THREE.Mesh(avatarGeometry, avatarMaterial);
      // ConeGeometry points UP by default - no rotation needed!
      
      // Add glow sphere around avatar
      const glowGeometry = new THREE.SphereGeometry(0.7, 16, 16);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0xff4d2e,
        transparent: true,
        opacity: 0.3,
        side: THREE.BackSide
      });
      const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
      avatarMesh.add(glowMesh);
      
      // Add flat billboard circle with two eyes on top
      const eyeCanvas = document.createElement('canvas');
      eyeCanvas.width = 64;
      eyeCanvas.height = 64;
      const eyeCtx = eyeCanvas.getContext('2d');
      
      // Draw circle background
      eyeCtx.fillStyle = '#ff4d2e';
      eyeCtx.beginPath();
      eyeCtx.arc(32, 32, 30, 0, Math.PI * 2);
      eyeCtx.fill();
      
      // Draw two eyes (black circles)
      eyeCtx.fillStyle = '#000';
      eyeCtx.beginPath();
      eyeCtx.arc(22, 28, 6, 0, Math.PI * 2);
      eyeCtx.fill();
      eyeCtx.beginPath();
      eyeCtx.arc(42, 28, 6, 0, Math.PI * 2);
      eyeCtx.fill();
      
      const eyeTexture = new THREE.CanvasTexture(eyeCanvas);
      const eyeSpriteMaterial = new THREE.SpriteMaterial({ 
        map: eyeTexture, 
        transparent: true,
        sizeAttenuation: false
      });
      const eyeSprite = new THREE.Sprite(eyeSpriteMaterial);
      eyeSprite.position.y = 1.5; // Above cone
      eyeSprite.scale.set(0.04, 0.04, 1); // SMALLER - half the size (0.08 ‚Üí 0.04)
      avatarMesh.add(eyeSprite);
      
      // Start at EDGE of grid (0, 4) for better visibility
      const edgePos = gridRowColToWorld(0, 4);
      avatarMesh.position.set(edgePos.x, 1, edgePos.z);
      scene.add(avatarMesh);
      
      channel.avatar = {
        mesh: avatarMesh,
        row: 0,  // Top edge
        col: 4,  // Center column
        inventory: [],
        successfulNegotiations: 0,
        failedNegotiations: 0
      };
      
      console.log('‚úÖ Avatar created at center (4, 4)');
      
      // Keep trainCars array for compatibility (empty now)
      const trainCars = [];
      
      // Store references
      channel.scene = scene;
      channel.camera = camera;
      channel.renderer = renderer;
      channel.controls = controls;
      channel.trainCars = trainCars;
      channel.trainCurve = createTrackCurve(TRACK_CONFIGS[channel.currentTrack].radius);
      channel.trainProgress = 0;
      channel.trainPaused = false;
      channel.atJunction = false;
      
      console.log('\n‚úÖ 3D SCENE INITIALIZATION COMPLETE');
      console.log('Summary:');
      console.log('  - Grid cells:', channel.gridCells.length);
      console.log('  - Rings:', Object.keys(TRACK_CONFIGS).length, '(' + Object.values(TRACK_CONFIGS).map(r => r.label).join(', ') + ')');
      console.log('  - Radar scanning lines:', radarLines.length, '(' + radarLines.map(r => r.axis).join(', ') + ')');
      console.log('  - Avatar position: (4, 4) - center of grid');
      console.log('  - Radar axes:', TRAINING_GROUND.AXES.length);
      console.log('  - Camera position:', camera.position.toArray());
      console.log('  - Scene ready for avatar movement and radar scanning\n');
      console.log('üéÆ Controls: ‚Üë‚Üê‚Üì‚Üí to move avatar, SPACE to interact with entities');
      TestSuite.log('‚úÖ', TestSuite.stage, '3D scene fully initialized with avatar and radar scanning');
      
      // RAYCASTER for entity clicking AND hovering
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let currentLabel = null;
      
      // HOVER handler for entity name labels
      canvas.addEventListener('mousemove', (event) => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        
        // Remove old label
        if (currentLabel) {
          currentLabel.remove();
          currentLabel = null;
        }
        
        if (intersects.length > 0) {
          const hoveredObject = intersects[0].object;
          
          // Show entity name label
          if (hoveredObject.userData.entity) {
            const entity = hoveredObject.userData.entity;
            const label = document.createElement('div');
            label.className = 'entity-label';
            label.textContent = `${entity.type}: ${entity.label}`;
            label.style.left = `${event.clientX + 10}px`;
            label.style.top = `${event.clientY - 30}px`;
            document.body.appendChild(label);
            currentLabel = label;
            canvas.style.cursor = 'pointer';
          }
          // Show orbital body info label
          else if (hoveredObject.parent && hoveredObject.parent.userData.isOrbital) {
            const bodyName = hoveredObject.parent.userData.bodyName || 'Orbital Body';
            const label = document.createElement('div');
            label.className = 'entity-label';
            label.textContent = `ü™ê ${bodyName}`;
            label.style.left = `${event.clientX + 10}px`;
            label.style.top = `${event.clientY - 30}px`;
            document.body.appendChild(label);
            currentLabel = label;
            canvas.style.cursor = 'pointer';
          }
          // Show moon info label
          else if (hoveredObject.userData.isMoon) {
            const moonName = hoveredObject.userData.moonName || 'Moon';
            const label = document.createElement('div');
            label.className = 'entity-label';
            label.textContent = `${moonName}`;
            label.style.left = `${event.clientX + 10}px`;
            label.style.top = `${event.clientY - 30}px`;
            document.body.appendChild(label);
            currentLabel = label;
            canvas.style.cursor = 'pointer';
          } else {
            canvas.style.cursor = 'default';
          }
        } else {
          canvas.style.cursor = 'default';
        }
      });
      
      canvas.addEventListener('click', (event) => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        
        if (intersects.length > 0) {
          const clickedObject = intersects[0].object;
          
          // Check if clicked object has entity data
          if (clickedObject.userData.entity) {
            const entity = clickedObject.userData.entity;
            addMessage(channel, 'system', `üéØ Clicked: ${entity.type} "${entity.label}" at (${entity.row},${entity.col})\n\nType your message to interact with this entity.`);
            renderMessages(channel);
            channel.dom.input.focus();
            TestSuite.log('üéØ', 'CLICK', `Entity clicked: ${entity.label}`);
            
            // Update hexagon radar based on position
            updateHexagonFromGridCell(entity.row + 1, entity.col + 1); // Convert 0-8 to 1-9
            
            // Visual feedback - flash the cell
            const cell = channel.gridCells[entity.row * 9 + entity.col];
            if (cell && cell.material) {
              const originalOpacity = cell.material.opacity;
              cell.material.opacity = 0.6;
              setTimeout(() => {
                cell.material.opacity = originalOpacity;
              }, 300);
            }
          }
          // Check if clicked object is a grid cell (even if empty)
          else if (clickedObject.userData.gridCell) {
            const row = clickedObject.userData.row;
            const col = clickedObject.userData.col;
            
            // Update hexagon radar based on grid position
            updateHexagonFromGridCell(row + 1, col + 1); // Convert 0-8 to 1-9
            
            // Visual feedback
            const originalOpacity = clickedObject.material.opacity;
            clickedObject.material.opacity = 0.4;
            setTimeout(() => {
              clickedObject.material.opacity = originalOpacity;
            }, 300);
            
            TestSuite.log('üéØ', 'GRID', `Grid cell clicked: (${row + 1}, ${col + 1})`);
          }
          // Orbital body click detection - chat with orbiting elements!
          else if (clickedObject.parent && clickedObject.parent.userData.isOrbital) {
            const bodyIndex = clickedObject.parent.userData.bodyIndex || 0;
            const bodyName = clickedObject.parent.userData.bodyName;
            const orbitRadius = clickedObject.parent.userData.orbitRadius;
            
            const bodyDescriptions = {
              'Print Era': 'üì∞ I orbit at the innermost ring. Literacy, linear thought, structured knowledge. Books gave humanity memory beyond the oral tradition.',
              'Radio Era': 'üìª I orbit in the second ring. The communal voice, broadcasting, immediate connection. I brought the world together through sound waves.',
              'Television Era': 'üì∫ I orbit in the third ring. Visual spectacle, mass culture, passive consumption. I created the global village through moving images.',
              'Internet Era': 'üåê I orbit in the fourth ring. The network, fragmented and participatory. Everyone speaks, chaos and connection intertwine.',
              'AI Era': 'ü§ñ I orbit at the outer edge. Synthetic intelligence, pattern recognition, probabilistic truth. I am the new medium that shapes all others.'
            };
            
            const bodyInfo = `${bodyName}\n\nOrbit radius: ${orbitRadius}m\n\n${bodyDescriptions[bodyName] || 'An orbital element in the media system.'}\n\nType @${bodyName.replace(' Era', '')} to chat with me!`;
            
            addMessage(channel, 'system', `ü™ê ${bodyInfo}\n\nCurrent ring: ${TRACK_CONFIGS[channel.currentTrack].label}`);
            renderMessages(channel);
            channel.dom.input.focus();
            TestSuite.log('ü™ê', 'CLICK', `${bodyName} clicked`);
          }
        }
      });
      
      TestSuite.log('‚úÖ', TestSuite.stage, '3D scene fully initialized with click handler');
      
      // Hexagon radar removed from HUD - now integrated into grid plane visualization
      
      // RENDER NODE DATASET ON GRID
      if (nodeDataset && (channel.sceneType === 'POLARITY_INNER' || channel.sceneType === 'POLARITY_OUTER')) {
        renderNodeDatasetOnGrid(channel);
      }
    }
    
    // FOCUS ON AXIS - Camera animation + chat integration
    window.focusOnAxis = function(channelId, axis, label) {
      const channel = appState.channels.get(channelId);
      if (!channel || !channel.camera || !channel.radarLines) return;
      
      console.log(`üéØ Focusing on axis: ${label} (${axis}) in channel ${channelId}`);
      
      // Find axis index
      const axisIndex = TRAINING_GROUND.AXES.indexOf(axis);
      if (axisIndex === -1) return;
      
      // Calculate axis position in 3D space (from radar line position)
      const angleStep = (Math.PI * 2) / TRAINING_GROUND.AXES.length;
      const angle = axisIndex * angleStep - Math.PI / 2;
      const maxRadius = 15; // Match radar radius
      
      const axisX = Math.cos(angle) * maxRadius;
      const axisZ = Math.sin(angle) * maxRadius;
      
      // Position camera OUTSIDE grid looking IN at axis (fringe position)
      const targetPos = {
        x: axisX * 2.5,  // Far outside on axis ray
        y: 8,            // Lower view (eye level with labels)
        z: axisZ * 2.5
      };
      
      const lookAtPos = {
        x: 0,  // Look at CENTER of grid
        y: 0,
        z: 0
      };
      
      // Smooth camera animation
      const startPos = { 
        x: channel.camera.position.x,
        y: channel.camera.position.y,
        z: channel.camera.position.z
      };
      
      const duration = 1000; // 1 second
      const startTime = Date.now();
      
      function animateCamera() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
        
        channel.camera.position.x = startPos.x + (targetPos.x - startPos.x) * eased;
        channel.camera.position.y = startPos.y + (targetPos.y - startPos.y) * eased;
        channel.camera.position.z = startPos.z + (targetPos.z - startPos.z) * eased;
        
        channel.camera.lookAt(lookAtPos.x, lookAtPos.y, lookAtPos.z);
        
        if (progress < 1) {
          requestAnimationFrame(animateCamera);
        } else {
          // Update controls target
          if (channel.controls) {
            channel.controls.target.set(lookAtPos.x, lookAtPos.y, lookAtPos.z);
            channel.controls.update();
          }
        }
      }
      
      animateCamera();
      
      // Highlight the axis in 3D scene
      const radarLineObj = channel.radarLines[axisIndex];
      if (radarLineObj && radarLineObj.line && radarLineObj.line.material) {
        const lineMaterial = radarLineObj.line.material;
        const originalColor = lineMaterial.color.getHex();
        const originalOpacity = lineMaterial.opacity;
        
        // Flash effect
        lineMaterial.color.setHex(0xffffff);
        lineMaterial.opacity = 1.0;
        lineMaterial.linewidth = 4; // Thicker line
        
        setTimeout(() => {
          lineMaterial.color.setHex(originalColor);
          lineMaterial.opacity = originalOpacity;
          lineMaterial.linewidth = 2;
        }, 500);
      }
      
      // Add chat message about axis with chat prompt
      const polarity = channel.sceneType === 'POLARITY_INNER' ? 'INNER' : 'OUTER';
      const emoji = polarity === 'INNER' ? 'üî¥' : 'üîµ';
      const color = polarity === 'INNER' ? '#ff5c7c' : '#569fff';
      
      // Get axis description from node dataset if available
      let axisDescription = `**${label}** axis represents ${polarity === 'INNER' ? 'subjective' : 'objective'} ${axis.toLowerCase()}.`;
      
      if (nodeDataset) {
        const axisNodes = nodeDataset.known_nodes.filter(n => 
          n.axis && n.axis.toUpperCase() === axis && 
          (polarity === 'INNER' ? n.polarity === 'Inner' : n.polarity === 'Outer')
        );
        
        if (axisNodes.length > 0) {
          const node = axisNodes[0];
          axisDescription += `\n\n**Position:** (${node.coordinate[0]}, ${node.coordinate[1]})\n**Name:** ${node.name}\n**Subtitle:** ${node.subtitle}`;
        }
      }
      
      addMessage(channel, 'system', `${emoji} **Focusing on: ${label}**\n\n${axisDescription}\n\nüí¨ Type **@${label}** to chat with this axis, or ask questions about ${polarity} ${axis}.`);
      renderMessages(channel);
      
      // Pre-fill input with @mention
      if (channel.dom.input) {
        channel.dom.input.value = `@${label} `;
        channel.dom.input.focus();
      }
      
      TestSuite.log('üéØ', 'AXIS-FOCUS', `Camera focused on ${label} (${axis})`);
    };
    
    // Render node dataset nodes on the grid
    function renderNodeDatasetOnGrid(channel) {
      if (!nodeDataset || !channel.gridCells) return;
      
      const isInner = channel.sceneType === 'POLARITY_INNER';
      const nodes = nodeDataset.known_nodes.filter(n => 
        isInner ? n.polarity === 'Inner' : n.polarity === 'Outer'
      );
      
      console.log(`üìç Rendering ${nodes.length} ${isInner ? 'INNER' : 'OUTER'} nodes on grid for channel ${channel.id}`);
      
      nodes.forEach(node => {
        const [row, col] = node.coordinate; // 1-indexed in dataset
        const gridRow = row - 1; // Convert to 0-indexed
        const gridCol = col - 1;
        
        if (gridRow >= 0 && gridRow < 9 && gridCol >= 0 && gridCol < 9) {
          const entity = {
            type: 'Location',
            label: node.name,
            row: gridRow,
            col: gridCol,
            nodeData: node
          };
          
          placeEntityOnGrid(channel, entity);
        }
      });
      
      console.log(`‚úÖ Node dataset rendered on ${isInner ? 'INNER' : 'OUTER'} grid`);
    }
    
    // Hexagon radar drawing function (from node-dataset-viewer.html)
    function drawHexagonRadar(canvas, innerValues, outerValues) {
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const centerX = 100;
      const centerY = 100;
      const radius = 80;
      
      // Clear canvas
      ctx.clearRect(0, 0, 200, 200);
      
      const axes = ['IDENTITY', 'EXPERIENCE', 'LANGUAGE', 'DOMAIN', 'PURPOSE', 'ORDER'];
      
      // Draw axes lines (subtle)
      ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(
          centerX + Math.cos(angle) * radius,
          centerY + Math.sin(angle) * radius
        );
        ctx.stroke();
      }
      
      // Draw OUTER polygon (blue)
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      for (let i = 0; i <= 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
        const value = outerValues[i % 6];
        const x = centerX + Math.cos(angle) * radius * value;
        const y = centerY + Math.sin(angle) * radius * value;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = 'rgba(86, 159, 255, 0.15)';
      ctx.fill();
      ctx.strokeStyle = '#569fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw INNER polygon (red)
      ctx.beginPath();
      for (let i = 0; i <= 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
        const value = innerValues[i % 6];
        const x = centerX + Math.cos(angle) * radius * value;
        const y = centerY + Math.sin(angle) * radius * value;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = 'rgba(255, 92, 124, 0.15)';
      ctx.fill();
      ctx.strokeStyle = '#ff5c7c';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.globalAlpha = 1.0;
      
      // Draw axis labels
      ctx.fillStyle = '#888';
      ctx.font = 'bold 7px Courier New';
      ctx.textAlign = 'center';
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
        const labelRadius = radius + 15;
        const x = centerX + Math.cos(angle) * labelRadius;
        const y = centerY + Math.sin(angle) * labelRadius;
        ctx.fillText(axes[i].substring(0, 3), x, y + 2);
      }
    }
    
    // Update hexagon based on grid cell click
    function updateHexagonFromGridCell(row, col) {
      if (!nodeDataset) return;
      
      // Find node at this coordinate
      const knownNode = nodeDataset.known_nodes.find(n => 
        n.coordinate[0] === row && n.coordinate[1] === col
      );
      
      const syntheticNode = nodeDataset.synthetic_nodes.find(n => 
        n.coordinate[0] === row && n.coordinate[1] === col
      );
      
      const node = knownNode || syntheticNode;
      if (!node) return;
      
      const axes = ['IDENTITY', 'EXPERIENCE', 'LANGUAGE', 'DOMAIN', 'PURPOSE', 'ORDER'];
      
      if (knownNode && knownNode.axis) {
        const axisIndex = axes.indexOf(knownNode.axis.toUpperCase());
        if (axisIndex >= 0) {
          if (knownNode.polarity === 'Inner') {
            hexagonAxisValues.inner[axisIndex] = 0.9;
            hexagonAxisValues.inner.forEach((v, i) => {
              if (i !== axisIndex) hexagonAxisValues.inner[i] = Math.max(0.2, v * 0.7);
            });
          } else {
            hexagonAxisValues.outer[axisIndex] = 0.9;
            hexagonAxisValues.outer.forEach((v, i) => {
              if (i !== axisIndex) hexagonAxisValues.outer[i] = Math.max(0.2, v * 0.7);
            });
          }
        }
      } else if (syntheticNode && syntheticNode.nearest_node) {
        // Boost based on nearest known node
        const nearestAxis = syntheticNode.nearest_node.split('(')[0].trim().split(' ')[0].toUpperCase();
        const axisIndex = axes.indexOf(nearestAxis);
        if (axisIndex >= 0) {
          hexagonAxisValues.inner[axisIndex] = Math.min(0.7, hexagonAxisValues.inner[axisIndex] + 0.2);
          hexagonAxisValues.outer[axisIndex] = Math.min(0.7, hexagonAxisValues.outer[axisIndex] + 0.2);
        }
      }
      
      // Hexagon rendering skipped - will be integrated into grid plane geometry (future enhancement)
      
      // Show node info in chat
      const channel = appState.channels.get(appState.currentChannelId);
      if (channel && node) {
        const polarity = knownNode ? knownNode.polarity : 'Synthetic';
        const color = polarity === 'Inner' ? 'üî¥' : polarity === 'Outer' ? 'üîµ' : '‚ö™';
        addMessage(channel, 'system', `${color} **${node.name}** (${row}, ${col})\n\n**SHED:** ${node.shedding}\n\n**INTEGRATE:** ${node.integrating}\n\n**GROUND:** ${node.grounding}`);
        renderMessages(channel);
      }
    }
    
    function animate3D() {
      requestAnimationFrame(animate3D);
      
      appState.channels.forEach(channel => {
        if (!channel.scene || !channel.renderer) return;
        
        // PHYSICS MODE: Calculate N-body gravitation
        if (channel.physicsEnabled && channel.freeEntities) {
          const G = 0.001; // Gravitational constant (tuned for visual effect)
          const dt = 0.016; // Time step (~60fps)
          
          // Update free entities with gravity
          channel.freeEntities.forEach((entity, idx) => {
            let forceX = 0;
            let forceZ = 0;
            
            // Calculate gravitational pull from all orbital bodies
            channel.trainCars.forEach(body => {
              const dx = body.group.position.x - entity.position.x;
              const dz = body.group.position.z - entity.position.z;
              const distSq = dx * dx + dz * dz;
              const dist = Math.sqrt(distSq);
              
              if (dist > 0.5) { // Prevent division by zero and super-close encounters
                const force = (G * body.mass * entity.mass) / distSq;
                forceX += (dx / dist) * force;
                forceZ += (dz / dist) * force;
                
                // Collision detection
                if (dist < (body.group.children[0].geometry.parameters.radius + entity.size + 0.5)) {
                  entity.crashed = true;
                  entity.crashedInto = body.group.userData.bodyName;
                }
              }
            });
            
            // Update velocity and position
            entity.velocity.x += (forceX / entity.mass) * dt;
            entity.velocity.z += (forceZ / entity.mass) * dt;
            
            entity.position.x += entity.velocity.x;
            entity.position.z += entity.velocity.z;
            
            // Update mesh
            if (entity.mesh) {
              entity.mesh.position.set(entity.position.x, entity.position.y, entity.position.z);
              
              // Trail visualization - create line geometry
              entity.trail.push({ x: entity.position.x, z: entity.position.z });
              if (entity.trail.length > 100) entity.trail.shift();
              
              // Update or create trail line
              if (entity.trail.length > 2) {
                if (!entity.trailLine) {
                  const trailGeom = new THREE.BufferGeometry();
                  const trailMat = new THREE.LineBasicMaterial({
                    color: entity.color,
                    opacity: 0.4,
                    transparent: true
                  });
                  entity.trailLine = new THREE.Line(trailGeom, trailMat);
                  channel.scene.add(entity.trailLine);
                }
                
                // Update trail geometry
                const positions = new Float32Array(entity.trail.length * 3);
                entity.trail.forEach((point, i) => {
                  positions[i * 3] = point.x;
                  positions[i * 3 + 1] = 0.5;
                  positions[i * 3 + 2] = point.z;
                });
                entity.trailLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                entity.trailLine.geometry.computeBoundingSphere();
              }
              
              // Change color if crashed
              if (entity.crashed) {
                entity.mesh.material.color.setHex(0xff0000);
                entity.mesh.material.emissive.setHex(0xff0000);
                if (entity.trailLine) {
                  entity.trailLine.material.color.setHex(0xff0000);
                }
              }
            }
          });
          
          // Check for stable orbits and notify (more frequently)
          if (Math.random() < 0.05) { // Check more often
            channel.freeEntities.forEach(entity => {
              if (entity.crashed && !entity.notified) {
                entity.notified = true;
                addMessage(channel, 'system', `üí• **${entity.name}** crashed into ${entity.crashedInto}!\n\nüî¥ Entity destroyed. Trail turns red.`);
                renderMessages(channel);
                TestSuite.log('üí•', 'CRASH', `${entity.name} ‚Üí ${entity.crashedInto}`);
              } else if (!entity.crashed && entity.trail.length > 50 && !entity.notified) {
                const speed = Math.sqrt(entity.velocity.x ** 2 + entity.velocity.z ** 2);
                const dist = Math.sqrt(entity.position.x ** 2 + entity.position.z ** 2);
                if (speed > 0.02 && speed < 0.2) {
                  entity.notified = true;
                  addMessage(channel, 'system', `‚ú® **${entity.name}** achieved stable orbit!\n\nüìä Speed: ${(speed * 100).toFixed(1)}%\nüìè Distance: ${dist.toFixed(1)} units\nüîµ Trail shows circular path`);
                  renderMessages(channel);
                  TestSuite.log('‚ú®', 'ORBIT', `${entity.name} stable at r=${dist.toFixed(1)}`);
                }
              }
            });
          }
        }
        
        // Update train position (only if not paused and physics off)
        if (!channel.trainPaused && !channel.physicsEnabled) {
          const direction = channel.trainDirection || 1;
          channel.trainProgress += 0.001 * direction; // Use direction for forward/backward
          
          // Wrap around
          if (channel.trainProgress >= 1) channel.trainProgress = 0;
          if (channel.trainProgress < 0) channel.trainProgress = 1;
        }
        
        // Safety check for currentTrack
        if (!channel.currentTrack || !TRACK_CONFIGS[channel.currentTrack]) {
          channel.currentTrack = 'shed';  // Default fallback
        }
        
        const mainRadius = TRACK_CONFIGS[channel.currentTrack].radius;
        const angle = channel.trainProgress * Math.PI * 2;
        const x = Math.cos(angle) * mainRadius;
        const z = Math.sin(angle) * mainRadius;
        
        // Perspective lock mode - follow specific orbital body
        if (channel.perspectiveLock !== null && channel.perspectiveLock !== undefined) {
          const lockedBody = channel.trainCars[channel.perspectiveLock];
          if (lockedBody && lockedBody.group) {
            const bodyPos = lockedBody.group.position;
            // Position camera behind and above the locked body
            const offset = new THREE.Vector3(0, 6, 10);
            channel.camera.position.copy(bodyPos).add(offset);
            channel.camera.lookAt(bodyPos.x, bodyPos.y, bodyPos.z);
          }
        }
        // Legacy camera follow mode
        else if (channel.cameraFollowMode && channel.trainCars && channel.trainCars.length > 0) {
          const locomotive = channel.trainCars[0];
          const trainPos = locomotive.group.position;
          const offset = new THREE.Vector3(0, 8, 12);
          channel.camera.position.copy(trainPos).add(offset);
          channel.camera.lookAt(trainPos.x, trainPos.y, trainPos.z);
        }
        
        // RADAR SCANNING ANIMATION: Calm, magical sweeping rays
        if (channel.radarLines) {
          const time = Date.now() * 0.001;
          
          channel.radarLines.forEach(ray => {
            // Safety check: skip if ray doesn't have line
            if (!ray || !ray.line || !ray.line.geometry) return;
            
            // SLOWER, CALMER: 8 seconds per sweep (was 3)
            const sweepDuration = 8;
            const phase = (time + ray.phase) % sweepDuration;
            const distance = (phase / sweepDuration) * 45;
            
            // Update line endpoint
            const endX = Math.cos(ray.angle) * distance;
            const endZ = Math.sin(ray.angle) * distance;
            
            const positions = ray.line.geometry.attributes.position.array;
            positions[3] = endX;  // End X
            positions[5] = endZ;  // End Z
            ray.line.geometry.attributes.position.needsUpdate = true;
            
            // MAGICAL: Smooth fade-in/out with glow at edges
            const fadeIn = Math.min(1, distance / 10);  // Fade in first 10 units
            const fadeOut = Math.max(0, 1 - ((distance - 35) / 10));  // Fade out last 10 units
            const magicalGlow = Math.sin(time * 2 + ray.phase) * 0.15 + 0.85;  // Subtle pulse
            
            // OBSERVER PULSE: Brighten rays when observer updates
            let observerPulseMultiplier = 1;
            if (channel.observerPulseActive) {
              const pulseAge = (Date.now() - channel.observerPulseTime) / 1000;  // Seconds
              if (pulseAge < 2) {
                // Smooth pulse wave that fades over 2 seconds
                observerPulseMultiplier = 1 + Math.sin(pulseAge * Math.PI * 3) * Math.exp(-pulseAge) * 2;
              } else {
                channel.observerPulseActive = false;
              }
            }
            
            ray.line.material.opacity = 0.2 * fadeIn * fadeOut * magicalGlow * observerPulseMultiplier;
            
            // LIGHT UP GRID CELLS: Check all grid cells the ray passes through
            if (channel.gridCells && distance > 2) {
              const entities = appState.gridEntities.get(channel.id) || [];
              
              // Check each grid cell
              channel.gridCells.forEach(cell => {
                if (!cell || !cell.material) return;  // Safety check
                
                // Convert cell position to angle
                const cellX = (cell.col - 4) * 5;
                const cellZ = (cell.row - 4) * 5;
                const cellAngle = Math.atan2(cellZ, cellX);
                const cellDist = Math.sqrt(cellX * cellX + cellZ * cellZ);
                
                // Normalize angle difference
                let angleDiff = Math.abs(cellAngle - ray.angle);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                
                // Check if ray is passing through this cell (wider cone, smoother)
                const isInCone = angleDiff < 0.4;  // 40¬∞ cone for smoother detection
                const isAtDistance = Math.abs(distance - cellDist) < 8;  // Wider detection window
                
                if (isInCone && isAtDistance) {
                  // Find if this cell has an entity
                  const hasEntity = entities.some(e => e.row === cell.row && e.col === cell.col);
                  
                  if (hasEntity) {
                    // MAGICAL GLOW: Light up cells with entities
                    let intensity = 1 - Math.abs(distance - cellDist) / 8;  // Fade based on distance
                    
                    // OBSERVER PULSE: Boost intensity during observer updates
                    if (channel.observerPulseActive && channel.role === 'OBSERVER') {
                      const pulseAge = (Date.now() - channel.observerPulseTime) / 1000;
                      if (pulseAge < 2) {
                        intensity *= 1 + Math.exp(-pulseAge * 1.5);  // Extra bright during pulse
                      }
                    }
                    
                    const glowColor = ray.color;
                    
                    // Update cell material with glow
                    if (cell.material) {
                      cell.material.emissive.setHex(glowColor);
                      cell.material.emissiveIntensity = intensity * 0.6;
                      cell.material.opacity = 0.15 + intensity * 0.3;
                      
                      // Mark for fade-out
                      if (!cell.glowTimeout) {
                        cell.glowTimeout = setTimeout(() => {
                          if (cell.material) {
                            // Smooth fade out
                            const fadeOut = setInterval(() => {
                              if (cell.material.emissiveIntensity > 0.01) {
                                cell.material.emissiveIntensity *= 0.8;
                                cell.material.opacity = 0.15 + cell.material.emissiveIntensity * 0.3;
                              } else {
                                cell.material.emissive.setHex(0x000000);
                                cell.material.emissiveIntensity = 0;
                                cell.material.opacity = 0.15;
                                clearInterval(fadeOut);
                              }
                            }, 50);
                            cell.glowTimeout = null;
                          }
                        }, 800);  // Hold glow for 800ms
                      }
                    }
                    
                    // Also glow the entity mesh itself
                    const entity = entities.find(e => e.row === cell.row && e.col === cell.col);
                    if (entity && entity.mesh && entity.mesh.material && !entity.glowActive) {
                      entity.glowActive = true;
                      const originalEmissive = entity.mesh.material.emissive.getHex();
                      entity.mesh.material.emissive.setHex(glowColor);
                      entity.mesh.material.emissiveIntensity = 0.8;
                      
                      setTimeout(() => {
                        if (entity.mesh && entity.mesh.material) {
                          entity.mesh.material.emissive.setHex(originalEmissive);
                          entity.mesh.material.emissiveIntensity = 0.3;
                          entity.glowActive = false;
                        }
                      }, 800);
                    }
                  }
                }
              });
            }
          });
        }
        
        // Orbit each body at its own radius and speed (DISABLED - using radar lines now)
        if (channel.trainCars && channel.trainCars.length > 0) {
          channel.trainCars.forEach((body, idx) => {
            if (!body || !body.group) return; // Safety check
          
          const radius = body.orbitRadius || 15;
          const speed = body.orbitSpeed || 0.001;
          
          // Calculate orbital position
          const angle = (channel.trainProgress + (idx * 0.2)) * Math.PI * 2;
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          
          body.group.position.set(x, 0.5, z);
          
          // Rotate body on its axis (self-rotation)
          body.group.rotation.y += speed * 5;
          
          // Animate glow ring tilt
          const glowRing = body.group.children[1];
          if (glowRing) {
            glowRing.rotation.x = Math.sin(Date.now() * 0.001) * 0.3;
          }
          
          // ANIMATE MOONS around this orbital body
          if (body.moons && body.moons.length > 0) {
            body.moons.forEach(moon => {
              if (!moon.mesh) return;
              
              // Update moon's orbital angle
              moon.angle += moon.speed;
              
              // Calculate moon position relative to host body
              const moonX = x + Math.cos(moon.angle) * moon.radius;
              const moonY = 0.5 + Math.sin(moon.angle * 2) * 0.5; // Slight vertical wobble
              const moonZ = z + Math.sin(moon.angle) * moon.radius;
              
              moon.mesh.position.set(moonX, moonY, moonZ);
              moon.mesh.rotation.y += 0.05; // Self-rotation
            });
          }
          });
        }
        
        // Update info overlay
        const pct = Math.floor(channel.trainProgress * 100);
        let status = channel.trainPaused ? 'üõë PAUSED' : 'üåå ORBITING';
        if (channel.physicsEnabled) {
          const entityCount = channel.freeEntities ? channel.freeEntities.length : 0;
          const crashed = channel.freeEntities ? channel.freeEntities.filter(e => e.crashed).length : 0;
          status = `‚öõÔ∏è PHYSICS ON (${entityCount} entities, ${crashed} crashed)`;
        }
        channel.dom.trainInfo.innerHTML = 
          `Ring: <strong>${TRACK_CONFIGS[channel.currentTrack].label}</strong><br>Cycle: <strong>${pct}%</strong><br>${status}`;
        
        // Update grid position
        updateGridPosition(channel, channel.trainProgress);
        
        // Render
        channel.controls.update();
        channel.renderer.render(channel.scene, channel.camera);
      });
    }
    
    // runStage9Tests removed - now inline in DOMContentLoaded
  </script>
</body>
</html>
